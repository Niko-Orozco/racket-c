[
    {
        "expresiones":
        {
            "1" : 
            {
                "1": "En este ejemplo se usa:\n\tExpresiones\n\tDefinición de Constantes\n\tAsignación\n\tLectura y Escritura por consola",
                "2": "\t\t\tRACKET\nCOMENTARIOS:\nLos comentarios pueden ser de una sola linea escribiendo: ;Esto es un comentario\nO pueden ser de varias lineas: \n#| Comentario\nVarias\nLineas |#\n\nEXPRESIONES:\nLas expresiones en racket se escriben entre paréntesis en modo preorden, lo que significa que se recorre la raiz, luego el nodo izquierdo y luego el derecho, es decir, si tenemos la suma: 2+3, sintácticamente se escribiría:\n\t (+ 2 3)\n\nOPERADORES:\nEn Racket Los operadores se escriben al igual que las expresiones, en Pre-Orden\nPara la asignación, re-asignación o reemplazar el valor de una variable se usa la palabra reservada set!\n\nIMPRIMIR POR CONSOLA:\nPara imprimir datos por consola en Racket, se usa la palabra reservada printf y entre comillas dobles se escribe el mensaje. Si se desea imprimir una variable se usa el símbolo: ~a\nSe escribe dentro de los símbolos y el nombre de la variable a imprimir se escribe luego de los símbolos.\nSintácticamente: Si tenemos una variable: numero\nSe imprime de este modo:\n\n(printf \"La variable es ~a\" numero)\n\nLEER POR CONSOLA:\nPara leer datos por consola en racket, se usa la palabra reservada del lenguaje: read, escrita entre paréntesis. \nSe usa en el momento en que se llama a una función, y reemplaza el nombre de la variable por (read) un dato que entra por consola.\nSintácticamente:\nSi tenemos una función (define(comparar (numero1 numero2))\n\tBloque de Instrucciones)\n\nEl llamado a la función seria: (comparar (read) (read))",
                "3": "\t\t\tC\nCOMENTARIOS:\nLos comentarios pueden ser de una sola linea escribiendo: //Esto es un comentario\n O de varias lineas: \n/* Comentario\nVarias\nLineas */\n\nEXPRESIONES:\nLas expresiones constan de operadores y operandos, estos pueden ser: \n\tAritméticos\n\tLógicos\n\tRelacionales\nEn el caso de los operadores arítmeticos se escriben en InOrden, es decir en el orden que normalmente se trabaja a nivel matemático.\n\nOPERADORES:\nEn C hay tres tipos de operadores, aritméticos, lógicos y relacionales los cuales se escriben en In-Orden.\nPara la asignación de un dato a una variable se usa el símbolo de igual =\n\nIMPRIMIR POR CONSOLA:\nPara imprimir datos por consola en C se usa la palabra reservada printf, función de la librería stdio.h (También scanf, para leer datos).\nSe escribe entre comillas dobles el mensaje a mostrar. Si se desea mostrar el valor de una variable se escribe dentro de las comillas el símbolo '%' con la letra que identifica al tipo de dato, luego de las comillas y separado por coma ',' se escribe el nombre de la variable a imprimir.\nSintácticamente: Si se tiene un variable de tipo entero: \nint variable=5;\n\nSe imprime del siguiente modo:\nprintf(\"La variable es: %d\", variable);\n\nLEER POR CONSOLA:\nPara leer datos por consola en C hay que tener en cuenta el tipo de dato que se quiere recoger, se usa la palabra reservada scanf junto con los símbolos '%' y '&'. \nSe escribe el tipo de dato al lado del porcentaje, ambos deben estar entre comillas doble.\nEl nombre de la variable donde se almacenará el valor debe aparecer precedida del símbolo ampersand, ambos luego de una coma.\nSintácticamente:\nSi tenemos una variable de tipo entero:\nint variable;\n\nLeemos un valor para dicha variable así: scanf(\"%d\", &variable);  "
            },
            "2" : 
            {
                "1": "En este ejemplo se usa:\n\tExpresiones\n\tDefinición de Constantes\n\tAsignación\n\tLectura y Escritura por consola",
                "2": "\t\t\tRACKET\nCOMENTARIOS:\nLos comentarios pueden ser de una sola linea escribiendo: ;Esto es un comentario\nO pueden ser de varias lineas: \n#| Comentario\nVarias\nLineas |#\n\nEXPRESIONES:\nLas expresiones en racket se escriben entre paréntesis en modo preorden, lo que significa que se recorre la raiz, luego el nodo izquierdo y luego el derecho, es decir, si tenemos la suma: 2+3, sintácticamente se escribiría:\n\t (+ 2 3)\n\nOPERADORES:\nEn Racket Los operadores se escriben al igual que las expresiones, en Pre-Orden\nPara la asignación, re-asignación o reemplazar el valor de una variable se usa la palabra reservada set!\n\nIMPRIMIR POR CONSOLA:\nPara imprimir datos por consola en Racket, se usa la palabra reservada printf y entre comillas dobles se escribe el mensaje. Si se desea imprimir una variable se usa el símbolo: ~a\nSe escribe dentro de los símbolos y el nombre de la variable a imprimir se escribe luego de los símbolos.\nSintácticamente: Si tenemos una variable: numero\nSe imprime de este modo:\n\n(printf \"La variable es ~a\" numero)\n\nLEER POR CONSOLA:\nPara leer datos por consola en racket, se usa la palabra reservada del lenguaje: read, escrita entre paréntesis. \nSe usa en el momento en que se llama a una función, y reemplaza el nombre de la variable por (read) un dato que entra por consola.\nSintácticamente:\nSi tenemos una función (define(comparar (numero1 numero2))\n\tBloque de Instrucciones)\n\nEl llamado a la función seria: (comparar (read) (read))",
                "3": "\t\t\tC\nCOMENTARIOS:\nLos comentarios pueden ser de una sola linea escribiendo: //Esto es un comentario\n O de varias lineas: \n/* Comentario\nVarias\nLineas */\n\nEXPRESIONES:\nLas expresiones constan de operadores y operandos, estos pueden ser: \n\tAritméticos\n\tLógicos\n\tRelacionales\nEn el caso de los operadores arítmeticos se escriben en InOrden, es decir en el orden que normalmente se trabaja a nivel matemático.\n\nOPERADORES:\nEn C hay tres tipos de operadores, aritméticos, lógicos y relacionales los cuales se escriben en In-Orden.\nPara la asignación de un dato a una variable se usa el símbolo de igual =\n\nIMPRIMIR POR CONSOLA:\nPara imprimir datos por consola en C se usa la palabra reservada printf, función de la librería stdio.h (También scanf, para leer datos).\nSe escribe entre comillas dobles el mensaje a mostrar. Si se desea mostrar el valor de una variable se escribe dentro de las comillas el símbolo '%' con la letra que identifica al tipo de dato, luego de las comillas y separado por coma ',' se escribe el nombre de la variable a imprimir.\nSintácticamente: Si se tiene un variable de tipo entero: \nint variable=5;\n\nSe imprime del siguiente modo:\nprintf(\"La variable es: %d\", variable);\n\nLEER POR CONSOLA:\nPara leer datos por consola en C hay que tener en cuenta el tipo de dato que se quiere recoger, se usa la palabra reservada scanf junto con los símbolos '%' y '&'. \nSe escribe el tipo de dato al lado del porcentaje, ambos deben estar entre comillas doble.\nEl nombre de la variable donde se almacenará el valor debe aparecer precedida del símbolo ampersand, ambos luego de una coma.\nSintácticamente:\nSi tenemos una variable de tipo entero:\nint variable;\n\nLeemos un valor para dicha variable así: scanf(\"%d\", &variable);  "
            },
            "3" : 
            {
                "1": "En este ejemplo se usa:\n\tExpresiones\n\tDefinición de Constantes\n\tAsignación\n\tLectura y Escritura por consola",
                "2": "\t\t\tRACKET\nCOMENTARIOS:\nLos comentarios pueden ser de una sola linea escribiendo: ;Esto es un comentario\nO pueden ser de varias lineas: \n#| Comentario\nVarias\nLineas |#\n\nEXPRESIONES:\nLas expresiones en racket se escriben entre paréntesis en modo preorden, lo que significa que se recorre la raiz, luego el nodo izquierdo y luego el derecho, es decir, si tenemos la suma: 2+3, sintácticamente se escribiría:\n\t (+ 2 3)\n\nOPERADORES:\nEn Racket Los operadores se escriben al igual que las expresiones, en Pre-Orden\nPara la asignación, re-asignación o reemplazar el valor de una variable se usa la palabra reservada set!\n\nIMPRIMIR POR CONSOLA:\nPara imprimir datos por consola en Racket, se usa la palabra reservada printf y entre comillas dobles se escribe el mensaje. Si se desea imprimir una variable se usa el símbolo: ~a\nSe escribe dentro de los símbolos y el nombre de la variable a imprimir se escribe luego de los símbolos.\nSintácticamente: Si tenemos una variable: numero\nSe imprime de este modo:\n\n(printf \"La variable es ~a\" numero)\n\nLEER POR CONSOLA:\nPara leer datos por consola en racket, se usa la palabra reservada del lenguaje: read, escrita entre paréntesis. \nSe usa en el momento en que se llama a una función, y reemplaza el nombre de la variable por (read) un dato que entra por consola.\nSintácticamente:\nSi tenemos una función (define(comparar (numero1 numero2))\n\tBloque de Instrucciones)\n\nEl llamado a la función seria: (comparar (read) (read))",
                "3": "\t\t\tC\nCOMENTARIOS:\nLos comentarios pueden ser de una sola linea escribiendo: //Esto es un comentario\n O de varias lineas: \n/* Comentario\nVarias\nLineas */\n\nEXPRESIONES:\nLas expresiones constan de operadores y operandos, estos pueden ser: \n\tAritméticos\n\tLógicos\n\tRelacionales\nEn el caso de los operadores arítmeticos se escriben en InOrden, es decir en el orden que normalmente se trabaja a nivel matemático.\n\nOPERADORES:\nEn C hay tres tipos de operadores, aritméticos, lógicos y relacionales los cuales se escriben en In-Orden.\nPara la asignación de un dato a una variable se usa el símbolo de igual =\n\nIMPRIMIR POR CONSOLA:\nPara imprimir datos por consola en C se usa la palabra reservada printf, función de la librería stdio.h (También scanf, para leer datos).\nSe escribe entre comillas dobles el mensaje a mostrar. Si se desea mostrar el valor de una variable se escribe dentro de las comillas el símbolo '%' con la letra que identifica al tipo de dato, luego de las comillas y separado por coma ',' se escribe el nombre de la variable a imprimir.\nSintácticamente: Si se tiene un variable de tipo entero: \nint variable=5;\n\nSe imprime del siguiente modo:\nprintf(\"La variable es: %d\", variable);\n\nLEER POR CONSOLA:\nPara leer datos por consola en C hay que tener en cuenta el tipo de dato que se quiere recoger, se usa la palabra reservada scanf junto con los símbolos '%' y '&'. \nSe escribe el tipo de dato al lado del porcentaje, ambos deben estar entre comillas doble.\nEl nombre de la variable donde se almacenará el valor debe aparecer precedida del símbolo ampersand, ambos luego de una coma.\nSintácticamente:\nSi tenemos una variable de tipo entero:\nint variable;\n\nLeemos un valor para dicha variable así: scanf(\"%d\", &variable);  "
            },
            "4" : 
            {
                "1": "En este ejemplo se usa:\n\tExpresiones\n\tDefinición de Constantes\n\tAsignación\n\tLectura y Escritura por consola",
                "2": "\t\t\tRACKET\nCOMENTARIOS:\nLos comentarios pueden ser de una sola linea escribiendo: ;Esto es un comentario\nO pueden ser de varias lineas: \n#| Comentario\nVarias\nLineas |#\n\nEXPRESIONES:\nLas expresiones en racket se escriben entre paréntesis en modo preorden, lo que significa que se recorre la raiz, luego el nodo izquierdo y luego el derecho, es decir, si tenemos la suma: 2+3, sintácticamente se escribiría:\n\t (+ 2 3)\n\nOPERADORES:\nEn Racket Los operadores se escriben al igual que las expresiones, en Pre-Orden\nPara la asignación, re-asignación o reemplazar el valor de una variable se usa la palabra reservada set!\n\nIMPRIMIR POR CONSOLA:\nPara imprimir datos por consola en Racket, se usa la palabra reservada printf y entre comillas dobles se escribe el mensaje. Si se desea imprimir una variable se usa el símbolo: ~a\nSe escribe dentro de los símbolos y el nombre de la variable a imprimir se escribe luego de los símbolos.\nSintácticamente: Si tenemos una variable: numero\nSe imprime de este modo:\n\n(printf \"La variable es ~a\" numero)\n\nLEER POR CONSOLA:\nPara leer datos por consola en racket, se usa la palabra reservada del lenguaje: read, escrita entre paréntesis. \nSe usa en el momento en que se llama a una función, y reemplaza el nombre de la variable por (read) un dato que entra por consola.\nSintácticamente:\nSi tenemos una función (define(comparar (numero1 numero2))\n\tBloque de Instrucciones)\n\nEl llamado a la función seria: (comparar (read) (read))",
                "3": "\t\t\tC\nCOMENTARIOS:\nLos comentarios pueden ser de una sola linea escribiendo: //Esto es un comentario\n O de varias lineas: \n/* Comentario\nVarias\nLineas */\n\nEXPRESIONES:\nLas expresiones constan de operadores y operandos, estos pueden ser: \n\tAritméticos\n\tLógicos\n\tRelacionales\nEn el caso de los operadores arítmeticos se escriben en InOrden, es decir en el orden que normalmente se trabaja a nivel matemático.\n\nOPERADORES:\nEn C hay tres tipos de operadores, aritméticos, lógicos y relacionales los cuales se escriben en In-Orden.\nPara la asignación de un dato a una variable se usa el símbolo de igual =\n\nIMPRIMIR POR CONSOLA:\nPara imprimir datos por consola en C se usa la palabra reservada printf, función de la librería stdio.h (También scanf, para leer datos).\nSe escribe entre comillas dobles el mensaje a mostrar. Si se desea mostrar el valor de una variable se escribe dentro de las comillas el símbolo '%' con la letra que identifica al tipo de dato, luego de las comillas y separado por coma ',' se escribe el nombre de la variable a imprimir.\nSintácticamente: Si se tiene un variable de tipo entero: \nint variable=5;\n\nSe imprime del siguiente modo:\nprintf(\"La variable es: %d\", variable);\n\nLEER POR CONSOLA:\nPara leer datos por consola en C hay que tener en cuenta el tipo de dato que se quiere recoger, se usa la palabra reservada scanf junto con los símbolos '%' y '&'. \nSe escribe el tipo de dato al lado del porcentaje, ambos deben estar entre comillas doble.\nEl nombre de la variable donde se almacenará el valor debe aparecer precedida del símbolo ampersand, ambos luego de una coma.\nSintácticamente:\nSi tenemos una variable de tipo entero:\nint variable;\n\nLeemos un valor para dicha variable así: scanf(\"%d\", &variable);  "
            },
            "5" : 
            {
                "1": "En este ejemplo se usa:\n\tExpresiones\n\tDefinición de Constantes\n\tAsignación\n\tLectura y Escritura por consola",
                "2": "\t\t\tRACKET\nCOMENTARIOS:\nLos comentarios pueden ser de una sola linea escribiendo: ;Esto es un comentario\nO pueden ser de varias lineas: \n#| Comentario\nVarias\nLineas |#\n\nEXPRESIONES:\nLas expresiones en racket se escriben entre paréntesis en modo preorden, lo que significa que se recorre la raiz, luego el nodo izquierdo y luego el derecho, es decir, si tenemos la suma: 2+3, sintácticamente se escribiría:\n\t (+ 2 3)\n\nOPERADORES:\nEn Racket Los operadores se escriben al igual que las expresiones, en Pre-Orden\nPara la asignación, re-asignación o reemplazar el valor de una variable se usa la palabra reservada set!\n\nIMPRIMIR POR CONSOLA:\nPara imprimir datos por consola en Racket, se usa la palabra reservada printf y entre comillas dobles se escribe el mensaje. Si se desea imprimir una variable se usa el símbolo: ~a\nSe escribe dentro de los símbolos y el nombre de la variable a imprimir se escribe luego de los símbolos.\nSintácticamente: Si tenemos una variable: numero\nSe imprime de este modo:\n\n(printf \"La variable es ~a\" numero)\n\nLEER POR CONSOLA:\nPara leer datos por consola en racket, se usa la palabra reservada del lenguaje: read, escrita entre paréntesis. \nSe usa en el momento en que se llama a una función, y reemplaza el nombre de la variable por (read) un dato que entra por consola.\nSintácticamente:\nSi tenemos una función (define(comparar (numero1 numero2))\n\tBloque de Instrucciones)\n\nEl llamado a la función seria: (comparar (read) (read))",
                "3": "\t\t\tC\nCOMENTARIOS:\nLos comentarios pueden ser de una sola linea escribiendo: //Esto es un comentario\n O de varias lineas: \n/* Comentario\nVarias\nLineas */\n\nEXPRESIONES:\nLas expresiones constan de operadores y operandos, estos pueden ser: \n\tAritméticos\n\tLógicos\n\tRelacionales\nEn el caso de los operadores arítmeticos se escriben en InOrden, es decir en el orden que normalmente se trabaja a nivel matemático.\n\nOPERADORES:\nEn C hay tres tipos de operadores, aritméticos, lógicos y relacionales los cuales se escriben en In-Orden.\nPara la asignación de un dato a una variable se usa el símbolo de igual =\n\nIMPRIMIR POR CONSOLA:\nPara imprimir datos por consola en C se usa la palabra reservada printf, función de la librería stdio.h (También scanf, para leer datos).\nSe escribe entre comillas dobles el mensaje a mostrar. Si se desea mostrar el valor de una variable se escribe dentro de las comillas el símbolo '%' con la letra que identifica al tipo de dato, luego de las comillas y separado por coma ',' se escribe el nombre de la variable a imprimir.\nSintácticamente: Si se tiene un variable de tipo entero: \nint variable=5;\n\nSe imprime del siguiente modo:\nprintf(\"La variable es: %d\", variable);\n\nLEER POR CONSOLA:\nPara leer datos por consola en C hay que tener en cuenta el tipo de dato que se quiere recoger, se usa la palabra reservada scanf junto con los símbolos '%' y '&'. \nSe escribe el tipo de dato al lado del porcentaje, ambos deben estar entre comillas doble.\nEl nombre de la variable donde se almacenará el valor debe aparecer precedida del símbolo ampersand, ambos luego de una coma.\nSintácticamente:\nSi tenemos una variable de tipo entero:\nint variable;\n\nLeemos un valor para dicha variable así: scanf(\"%d\", &variable);  "
            },
            "6" : 
            {
                "1": "En este ejemplo se usa:\n\tExpresiones\n\tDefinición de Constantes\n\tAsignación\n\tLectura y Escritura por consola",
                "2": "\t\t\tRACKET\nCOMENTARIOS:\nLos comentarios pueden ser de una sola linea escribiendo: ;Esto es un comentario\nO pueden ser de varias lineas: \n#| Comentario\nVarias\nLineas |#\n\nEXPRESIONES:\nLas expresiones en racket se escriben entre paréntesis en modo preorden, lo que significa que se recorre la raiz, luego el nodo izquierdo y luego el derecho, es decir, si tenemos la suma: 2+3, sintácticamente se escribiría:\n\t (+ 2 3)\n\nOPERADORES:\nEn Racket Los operadores se escriben al igual que las expresiones, en Pre-Orden\nPara la asignación, re-asignación o reemplazar el valor de una variable se usa la palabra reservada set!\n\nIMPRIMIR POR CONSOLA:\nPara imprimir datos por consola en Racket, se usa la palabra reservada printf y entre comillas dobles se escribe el mensaje. Si se desea imprimir una variable se usa el símbolo: ~a\nSe escribe dentro de los símbolos y el nombre de la variable a imprimir se escribe luego de los símbolos.\nSintácticamente: Si tenemos una variable: numero\nSe imprime de este modo:\n\n(printf \"La variable es ~a\" numero)\n\nLEER POR CONSOLA:\nPara leer datos por consola en racket, se usa la palabra reservada del lenguaje: read, escrita entre paréntesis. \nSe usa en el momento en que se llama a una función, y reemplaza el nombre de la variable por (read) un dato que entra por consola.\nSintácticamente:\nSi tenemos una función (define(comparar (numero1 numero2))\n\tBloque de Instrucciones)\n\nEl llamado a la función seria: (comparar (read) (read))",
                "3": "\t\t\tC\nCOMENTARIOS:\nLos comentarios pueden ser de una sola linea escribiendo: //Esto es un comentario\n O de varias lineas: \n/* Comentario\nVarias\nLineas */\n\nEXPRESIONES:\nLas expresiones constan de operadores y operandos, estos pueden ser: \n\tAritméticos\n\tLógicos\n\tRelacionales\nEn el caso de los operadores arítmeticos se escriben en InOrden, es decir en el orden que normalmente se trabaja a nivel matemático.\n\nOPERADORES:\nEn C hay tres tipos de operadores, aritméticos, lógicos y relacionales los cuales se escriben en In-Orden.\nPara la asignación de un dato a una variable se usa el símbolo de igual =\n\nIMPRIMIR POR CONSOLA:\nPara imprimir datos por consola en C se usa la palabra reservada printf, función de la librería stdio.h (También scanf, para leer datos).\nSe escribe entre comillas dobles el mensaje a mostrar. Si se desea mostrar el valor de una variable se escribe dentro de las comillas el símbolo '%' con la letra que identifica al tipo de dato, luego de las comillas y separado por coma ',' se escribe el nombre de la variable a imprimir.\nSintácticamente: Si se tiene un variable de tipo entero: \nint variable=5;\n\nSe imprime del siguiente modo:\nprintf(\"La variable es: %d\", variable);\n\nLEER POR CONSOLA:\nPara leer datos por consola en C hay que tener en cuenta el tipo de dato que se quiere recoger, se usa la palabra reservada scanf junto con los símbolos '%' y '&'. \nSe escribe el tipo de dato al lado del porcentaje, ambos deben estar entre comillas doble.\nEl nombre de la variable donde se almacenará el valor debe aparecer precedida del símbolo ampersand, ambos luego de una coma.\nSintácticamente:\nSi tenemos una variable de tipo entero:\nint variable;\n\nLeemos un valor para dicha variable así: scanf(\"%d\", &variable);  "
            }
        },

        "secuencia":
        {
            "1" : 
            {
                "1": "En este ejemplo se usa:\n\tExpresiones\n\tDefinición de Variables\n\tUso de Operadores",
                "2": "\t\t\tRACKET\nEXPRESIONES:\nLas expresiones en racket se escriben entre paréntesis en modo preorden, lo que significa que se recorre la raiz, luego el nodo izquierdo y luego el derecho, es decir, si tenemos la suma: 2+3, sintácticamente se escribiría:\n\t (+ 2 3)\n\nOPERADORES:\nEn Racket Los operadores se escriben al igual que las expresiones, en Pre-Orden\nPara la asignación, re-asignación o reemplazar el valor de una variable se usa la palabra reservada set!",
                "3": "\t\t\tC\nEXPRESIONES:\nLas expresiones constan de operadores y operandos, estos pueden ser: \n\tAritméticos\n\tLógicos\n\tRelacionales\nEn el caso de los operadores arítmeticos se escriben en InOrden, es decir en el orden que normalmente se trabaja a nivel matemático.\n\nOPERADORES:\nEn C hay tres tipos de operadores, aritméticos, lógicos y relacionales los cuales se escriben en In-Orden.\nPara la asignación de un dato a una variable se usa el símbolo de igual ="
            },
            "2" : 
            {
                "1": "En este ejemplo se usa:\n\tExpresiones\n\tDefinición de Variables\n\tUso de Operadores\n\tImpresión por Consola",
                "2": "\t\t\tRACKET\nEXPRESIONES:\nLas expresiones en racket se escriben entre paréntesis en modo preorden, lo que significa que se recorre la raiz, luego el nodo izquierdo y luego el derecho, es decir, si tenemos la suma: 2+3, sintácticamente se escribiría:\n\t (+ 2 3)\n\nOPERADORES:\nEn Racket Los operadores se escriben al igual que las expresiones, en Pre-Orden\nPara la asignación, re-asignación o reemplazar el valor de una variable se usa la palabra reservada set!\n\nIMPRIMIR POR CONSOLA:\nPara imprimir datos por consola en Racket, se usa la palabra reservada printf y entre comillas dobles se escribe el mensaje. Si se desea imprimir una variable se usa el símbolo: ~a\nSe escribe dentro de los símbolos y el nombre de la variable a imprimir se escribe luego de los símbolos.\nSintácticamente: Si tenemos una variable: numero\nSe imprime de este modo:\n\n(printf \"La variable es ~a\" numero)",
                "3": "\t\t\tC\nEXPRESIONES:\nLas expresiones constan de operadores y operandos, estos pueden ser: \n\tAritméticos\n\tLógicos\n\tRelacionales\nEn el caso de los operadores arítmeticos se escriben en InOrden, es decir en el orden que normalmente se trabaja a nivel matemático.\n\nOPERADORES:\nEn C hay tres tipos de operadores, aritméticos, lógicos y relacionales los cuales se escriben en In-Orden.\nPara la asignación de un dato a una variable se usa el símbolo de igual =\n\nIMPRIMIR POR CONSOLA:\nPara imprimir datos por consola en C se usa la palabra reservada printf, función de la librería stdio.h (También scanf, para leer datos).\nSe escribe entre comillas dobles el mensaje a mostrar. Si se desea mostrar el valor de una variable se escribe dentro de las comillas el símbolo '%' con la letra que identifica al tipo de dato, luego de las comillas y separado por coma ',' se escribe el nombre de la variable a imprimir.\nSintácticamente: Si se tiene un variable de tipo entero: \nint variable=5;\n\nSe imprime del siguiente modo:\nprintf(\"La variable es: %d\", variable);"
            },
            "3" : 
            {
                "1": "En este ejemplo se usa:\n\tExpresiones\n\tDefinición de Variables\n\tUso de Operadores\n\tImpresión por Consola\n\tLectura por consola",
                "2": "\t\t\tRACKET\nEXPRESIONES:\nLas expresiones en racket se escriben entre paréntesis en modo preorden, lo que significa que se recorre la raiz, luego el nodo izquierdo y luego el derecho, es decir, si tenemos la suma: 2+3, sintácticamente se escribiría:\n\t (+ 2 3)\n\nOPERADORES:\nEn Racket Los operadores se escriben al igual que las expresiones, en Pre-Orden\nPara la asignación, re-asignación o reemplazar el valor de una variable se usa la palabra reservada set!\n\nIMPRIMIR POR CONSOLA:\nPara imprimir datos por consola en Racket, se usa la palabra reservada printf y entre comillas dobles se escribe el mensaje. Si se desea imprimir una variable se usa el símbolo: ~a\nSe escribe dentro de los símbolos y el nombre de la variable a imprimir se escribe luego de los símbolos.\nSintácticamente: Si tenemos una variable: numero\nSe imprime de este modo:\n\n(printf \"La variable es ~a\" numero)\n\nLEER POR CONSOLA:\nPara leer datos por consola en racket, se usa la palabra reservada del lenguaje: read, escrita entre paréntesis. \nSe usa en el momento en que se llama a una función, y reemplaza el nombre de la variable por (read) un dato que entra por consola.\nSintácticamente:\nSi tenemos una función (define(comparar (numero1 numero2))\n\tBloque de Instrucciones)\n\nEl llamado a la función seria: (comparar (read) (read))",
                "3": "\t\t\tC\nEXPRESIONES:\nLas expresiones constan de operadores y operandos, estos pueden ser: \n\tAritméticos\n\tLógicos\n\tRelacionales\nEn el caso de los operadores arítmeticos se escriben en InOrden, es decir en el orden que normalmente se trabaja a nivel matemático.\n\nOPERADORES:\nEn C hay tres tipos de operadores, aritméticos, lógicos y relacionales los cuales se escriben en In-Orden.\nPara la asignación de un dato a una variable se usa el símbolo de igual =\n\nIMPRIMIR POR CONSOLA:\nPara imprimir datos por consola en C se usa la palabra reservada printf, función de la librería stdio.h (También scanf, para leer datos).\nSe escribe entre comillas dobles el mensaje a mostrar. Si se desea mostrar el valor de una variable se escribe dentro de las comillas el símbolo '%' con la letra que identifica al tipo de dato, luego de las comillas y separado por coma ',' se escribe el nombre de la variable a imprimir.\nSintácticamente: Si se tiene un variable de tipo entero: \nint variable=5;\n\nSe imprime del siguiente modo:\nprintf(\"La variable es: %d\", variable);\n\nLEER POR CONSOLA:\nPara leer datos por consola en C hay que tener en cuenta el tipo de dato que se quiere recoger, se usa la palabra reservada scanf junto con los símbolos '%' y '&'. \nSe escribe el tipo de dato al lado del porcentaje, ambos deben estar entre comillas doble.\nEl nombre de la variable donde se almacenará el valor debe aparecer precedida del símbolo ampersand, ambos luego de una coma.\nSintácticamente:\nSi tenemos una variable de tipo entero:\nint variable;\n\nLeemos un valor para dicha variable así: scanf(\"%d\", &variable);  "
            },
            "4" : 
            {
                "1": "En este ejemplo se usa:\n\tExpresiones\n\tDefinición de Variables\n\tUso de Operadores\n\tImpresión por Consola\n\tLectura por consola",
                "2": "\t\t\tRACKET\nEXPRESIONES:\nLas expresiones en racket se escriben entre paréntesis en modo preorden, lo que significa que se recorre la raiz, luego el nodo izquierdo y luego el derecho, es decir, si tenemos la suma: 2+3, sintácticamente se escribiría:\n\t (+ 2 3)\n\nOPERADORES:\nEn Racket Los operadores se escriben al igual que las expresiones, en Pre-Orden\nPara la asignación, re-asignación o reemplazar el valor de una variable se usa la palabra reservada set!\n\nIMPRIMIR POR CONSOLA:\nPara imprimir datos por consola en Racket, se usa la palabra reservada printf y entre comillas dobles se escribe el mensaje. Si se desea imprimir una variable se usa el símbolo: ~a\nSe escribe dentro de los símbolos y el nombre de la variable a imprimir se escribe luego de los símbolos.\nSintácticamente: Si tenemos una variable: numero\nSe imprime de este modo:\n\n(printf \"La variable es ~a\" numero)\n\nLEER POR CONSOLA:\nPara leer datos por consola en racket, se usa la palabra reservada del lenguaje: read, escrita entre paréntesis. \nSe usa en el momento en que se llama a una función, y reemplaza el nombre de la variable por (read) un dato que entra por consola.\nSintácticamente:\nSi tenemos una función (define(comparar (numero1 numero2))\n\tBloque de Instrucciones)\n\nEl llamado a la función seria: (comparar (read) (read))",
                "3": "\t\t\tC\nEXPRESIONES:\nLas expresiones constan de operadores y operandos, estos pueden ser: \n\tAritméticos\n\tLógicos\n\tRelacionales\nEn el caso de los operadores arítmeticos se escriben en InOrden, es decir en el orden que normalmente se trabaja a nivel matemático.\n\nOPERADORES:\nEn C hay tres tipos de operadores, aritméticos, lógicos y relacionales los cuales se escriben en In-Orden.\nPara la asignación de un dato a una variable se usa el símbolo de igual =\n\nIMPRIMIR POR CONSOLA:\nPara imprimir datos por consola en C se usa la palabra reservada printf, función de la librería stdio.h (También scanf, para leer datos).\nSe escribe entre comillas dobles el mensaje a mostrar. Si se desea mostrar el valor de una variable se escribe dentro de las comillas el símbolo '%' con la letra que identifica al tipo de dato, luego de las comillas y separado por coma ',' se escribe el nombre de la variable a imprimir.\nSintácticamente: Si se tiene un variable de tipo entero: \nint variable=5;\n\nSe imprime del siguiente modo:\nprintf(\"La variable es: %d\", variable);\n\nLEER POR CONSOLA:\nPara leer datos por consola en C hay que tener en cuenta el tipo de dato que se quiere recoger, se usa la palabra reservada scanf junto con los símbolos '%' y '&'. \nSe escribe el tipo de dato al lado del porcentaje, ambos deben estar entre comillas doble.\nEl nombre de la variable donde se almacenará el valor debe aparecer precedida del símbolo ampersand, ambos luego de una coma.\nSintácticamente:\nSi tenemos una variable de tipo entero:\nint variable;\n\nLeemos un valor para dicha variable así: scanf(\"%d\", &variable);  "
            },
            "5" : 
            {
                "1": "En este ejemplo se usa:\n\tExpresiones\n\tDefinición de Variables\n\tUso de Operadores\n\tImpresión por Consola\n\tLectura por consola",
                "2": "\t\t\tRACKET\nEXPRESIONES:\nLas expresiones en racket se escriben entre paréntesis en modo preorden, lo que significa que se recorre la raiz, luego el nodo izquierdo y luego el derecho, es decir, si tenemos la suma: 2+3, sintácticamente se escribiría:\n\t (+ 2 3)\n\nOPERADORES:\nEn Racket Los operadores se escriben al igual que las expresiones, en Pre-Orden\nPara la asignación, re-asignación o reemplazar el valor de una variable se usa la palabra reservada set!\n\nIMPRIMIR POR CONSOLA:\nPara imprimir datos por consola en Racket, se usa la palabra reservada printf y entre comillas dobles se escribe el mensaje. Si se desea imprimir una variable se usa el símbolo: ~a\nSe escribe dentro de los símbolos y el nombre de la variable a imprimir se escribe luego de los símbolos.\nSintácticamente: Si tenemos una variable: numero\nSe imprime de este modo:\n\n(printf \"La variable es ~a\" numero)\n\nLEER POR CONSOLA:\nPara leer datos por consola en racket, se usa la palabra reservada del lenguaje: read, escrita entre paréntesis. \nSe usa en el momento en que se llama a una función, y reemplaza el nombre de la variable por (read) un dato que entra por consola.\nSintácticamente:\nSi tenemos una función (define(comparar (numero1 numero2))\n\tBloque de Instrucciones)\n\nEl llamado a la función seria: (comparar (read) (read))",
                "3": "\t\t\tC\nEXPRESIONES:\nLas expresiones constan de operadores y operandos, estos pueden ser: \n\tAritméticos\n\tLógicos\n\tRelacionales\nEn el caso de los operadores arítmeticos se escriben en InOrden, es decir en el orden que normalmente se trabaja a nivel matemático.\n\nOPERADORES:\nEn C hay tres tipos de operadores, aritméticos, lógicos y relacionales los cuales se escriben en In-Orden.\nPara la asignación de un dato a una variable se usa el símbolo de igual =\n\nIMPRIMIR POR CONSOLA:\nPara imprimir datos por consola en C se usa la palabra reservada printf, función de la librería stdio.h (También scanf, para leer datos).\nSe escribe entre comillas dobles el mensaje a mostrar. Si se desea mostrar el valor de una variable se escribe dentro de las comillas el símbolo '%' con la letra que identifica al tipo de dato, luego de las comillas y separado por coma ',' se escribe el nombre de la variable a imprimir.\nSintácticamente: Si se tiene un variable de tipo entero: \nint variable=5;\n\nSe imprime del siguiente modo:\nprintf(\"La variable es: %d\", variable);\n\nLEER POR CONSOLA:\nPara leer datos por consola en C hay que tener en cuenta el tipo de dato que se quiere recoger, se usa la palabra reservada scanf junto con los símbolos '%' y '&'. \nSe escribe el tipo de dato al lado del porcentaje, ambos deben estar entre comillas doble.\nEl nombre de la variable donde se almacenará el valor debe aparecer precedida del símbolo ampersand, ambos luego de una coma.\nSintácticamente:\nSi tenemos una variable de tipo entero:\nint variable;\n\nLeemos un valor para dicha variable así: scanf(\"%d\", &variable);  "
            },
            "6" : 
            {
                "1": "En este ejemplo se usa:\n\tExpresiones\n\tDefinición de Variables\n\tUso de Operadores\n\tImpresión por Consola\n\tLectura por consola",
                "2": "\t\t\tRACKET\nEXPRESIONES:\nLas expresiones en racket se escriben entre paréntesis en modo preorden, lo que significa que se recorre la raiz, luego el nodo izquierdo y luego el derecho, es decir, si tenemos la suma: 2+3, sintácticamente se escribiría:\n\t (+ 2 3)\n\nOPERADORES:\nEn Racket Los operadores se escriben al igual que las expresiones, en Pre-Orden\nPara la asignación, re-asignación o reemplazar el valor de una variable se usa la palabra reservada set!\n\nIMPRIMIR POR CONSOLA:\nPara imprimir datos por consola en Racket, se usa la palabra reservada printf y entre comillas dobles se escribe el mensaje. Si se desea imprimir una variable se usa el símbolo: ~a\nSe escribe dentro de los símbolos y el nombre de la variable a imprimir se escribe luego de los símbolos.\nSintácticamente: Si tenemos una variable: numero\nSe imprime de este modo:\n\n(printf \"La variable es ~a\" numero)\n\nLEER POR CONSOLA:\nPara leer datos por consola en racket, se usa la palabra reservada del lenguaje: read, escrita entre paréntesis. \nSe usa en el momento en que se llama a una función, y reemplaza el nombre de la variable por (read) un dato que entra por consola.\nSintácticamente:\nSi tenemos una función (define(comparar (numero1 numero2))\n\tBloque de Instrucciones)\n\nEl llamado a la función seria: (comparar (read) (read))",
                "3": "\t\t\tC\nEXPRESIONES:\nLas expresiones constan de operadores y operandos, estos pueden ser: \n\tAritméticos\n\tLógicos\n\tRelacionales\nEn el caso de los operadores arítmeticos se escriben en InOrden, es decir en el orden que normalmente se trabaja a nivel matemático.\n\nOPERADORES:\nEn C hay tres tipos de operadores, aritméticos, lógicos y relacionales los cuales se escriben en In-Orden.\nPara la asignación de un dato a una variable se usa el símbolo de igual =\n\nIMPRIMIR POR CONSOLA:\nPara imprimir datos por consola en C se usa la palabra reservada printf, función de la librería stdio.h (También scanf, para leer datos).\nSe escribe entre comillas dobles el mensaje a mostrar. Si se desea mostrar el valor de una variable se escribe dentro de las comillas el símbolo '%' con la letra que identifica al tipo de dato, luego de las comillas y separado por coma ',' se escribe el nombre de la variable a imprimir.\nSintácticamente: Si se tiene un variable de tipo entero: \nint variable=5;\n\nSe imprime del siguiente modo:\nprintf(\"La variable es: %d\", variable);\n\nLEER POR CONSOLA:\nPara leer datos por consola en C hay que tener en cuenta el tipo de dato que se quiere recoger, se usa la palabra reservada scanf junto con los símbolos '%' y '&'. \nSe escribe el tipo de dato al lado del porcentaje, ambos deben estar entre comillas doble.\nEl nombre de la variable donde se almacenará el valor debe aparecer precedida del símbolo ampersand, ambos luego de una coma.\nSintácticamente:\nSi tenemos una variable de tipo entero:\nint variable;\n\nLeemos un valor para dicha variable así: scanf(\"%d\", &variable);  "
            }
        },

        "condicionales":
        {
            "1" : 
            {
                "1": "En este ejemplo se usa:\n\tCondicional Simple: IF",
                "2": "\t\t\tRACKET\nSELECCIÓN SIMPLE:\nLa sentencia if analiza una condición escrita entre paréntesis, en caso de ser verdadera ejecuta la primera sentencia, sino, ejecuta la segunda.\nSintácticamente:\n(if(condicion)\n\tcondicion_true\n\tcondicion_false\n)",
                "3": "\t\t\tC\nSELECCIÓN SIMPLE:\nLa sentencia if evalua una condición escrita entre paréntesis y ejecuta la siguiente instrucción o conjunto de instrucciones.\nSintácticamente:\nif(condicion){\n\tBloque instrucciones\n}"
            },
            "2" : 
            {
                "1": "En este ejemplo se usa:\n\tCondicional Simple: IF",
                "2": "\t\t\tRACKET\nSELECCIÓN SIMPLE:\nLa sentencia if analiza una condición escrita entre paréntesis, en caso de ser verdadera ejecuta la primera sentencia, sino, ejecuta la segunda.\nSintácticamente:\n(if(condicion)\n\tcondicion_true\n\tcondicion_false\n)",
                "3": "\t\t\tC\nSELECCIÓN SIMPLE:\nLa sentencia if evalua una condición escrita entre paréntesis y ejecuta la siguiente instrucción o conjunto de instrucciones.\nSintácticamente:\nif(condicion){\n\tBloque instrucciones\n}"
            },
            "3" : 
            {
                "1": "En este ejemplo se usa:\n\tCondicional Simple: IF",
                "2": "\t\t\tRACKET\nSELECCIÓN SIMPLE:\nLa sentencia if analiza una condición escrita entre paréntesis, en caso de ser verdadera ejecuta la primera sentencia, sino, ejecuta la segunda.\nSintácticamente:\n(if(condicion)\n\tcondicion_true\n\tcondicion_false\n)",
                "3": "\t\t\tC\nSELECCIÓN SIMPLE:\nLa sentencia if evalua una condición escrita entre paréntesis y ejecuta la siguiente instrucción o conjunto de instrucciones.\nSintácticamente:\nif(condicion){\n\tBloque instrucciones\n}"
            },
            "4" : 
            {
                "1": "En este ejemplo se usa:\n\tCondicional Múltiple: COND/SWITCH-CASE",
                "2": "\t\t\tRACKET\nSELECCIÓN MÚLTIPLE:\nPara las selecciones múltiples se usa la palabra reservada COND y se analizan distintas opciones escritas entre paréntesis, dentro de cada posible opción se hace una comparación y si esta es verdadera, se ejecuta la instrucción continua. Si ninguna condición se cumple se puede colocar una opción por defecto con la palabra de reservada: else.\n\nSintácticamnete: ( COND\n\t[(= opcion 1)(Instrucciones para opción 1)] \n\t[(= opcion 2)(Instrucciones para opción 2)]\n\t[else (Instrucciones por defecto)] )",
                "3": "\t\t\tC\nSELECCIÓN MÚLTIPLE:\nPara seleccionar de manera múltiple se usa el switch-Case, dos palabras reservadas que de acuerdo al valor de una variable analizan n posibilidades distintas, también existe la posibilidad de asignar instrucciones cuando la variable no toma ningun valor dentro de los posibles casos.\nCada uno de los casos debe tener la palabra reservada: break para garantizar la salida de la estructura.\nSintácticamente:\nswitch(variable){\n\tCase 1: Opcion1\n\tCase 2: Opcion2\n\t.\n\tCase N: OpcionN\n\t.\n\tdefault: Opcion_por_defecto\n}"
            },
            "5" : 
            {
                "1": "En este ejemplo se usa:\n\tCondicional Múltiple: COND/SWITCH-CASE",
                "2": "\t\t\tRACKET\nSELECCIÓN MÚLTIPLE:\nPara las selecciones múltiples se usa la palabra reservada COND y se analizan distintas opciones escritas entre paréntesis, dentro de cada posible opción se hace una comparación y si esta es verdadera, se ejecuta la instrucción continua. Si ninguna condición se cumple se puede colocar una opción por defecto con la palabra de reservada: else.\n\nSintácticamnete: ( COND\n\t[(= opcion 1)(Instrucciones para opción 1)] \n\t[(= opcion 2)(Instrucciones para opción 2)]\n\t[else (Instrucciones por defecto)] )",
                "3": "\t\t\tC\nSELECCIÓN MÚLTIPLE:\nPara seleccionar de manera múltiple se usa el switch-Case, dos palabras reservadas que de acuerdo al valor de una variable analizan n posibilidades distintas, también existe la posibilidad de asignar instrucciones cuando la variable no toma ningun valor dentro de los posibles casos.\nCada uno de los casos debe tener la palabra reservada: break para garantizar la salida de la estructura.\nSintácticamente:\nswitch(variable){\n\tCase 1: Opcion1\n\tCase 2: Opcion2\n\t.\n\tCase N: OpcionN\n\t.\n\tdefault: Opcion_por_defecto\n}"
            },
            "6" : 
            {
                "1": "En este ejemplo se usa:\n\tCondicional Múltiple: COND/SWITCH-CASE\n\tCondicional Simple: IF",
                "2": "\t\t\tRACKET\nSELECCIÓN MÚLTIPLE:\nPara las selecciones múltiples se usa la palabra reservada COND y se analizan distintas opciones escritas entre paréntesis, dentro de cada posible opción se hace una comparación y si esta es verdadera, se ejecuta la instrucción continua. Si ninguna condición se cumple se puede colocar una opción por defecto con la palabra de reservada: else.\n\nSintácticamnete: ( COND\n\t[(= opcion 1)(Instrucciones para opción 1)] \n\t[(= opcion 2)(Instrucciones para opción 2)]\n\t[else (Instrucciones por defecto)] )\n\nSELECCIÓN SIMPLE:\nLa sentencia if analiza una condición escrita entre paréntesis, en caso de ser verdadera ejecuta la primera sentencia, sino, ejecuta la segunda.\nSintácticamente:\n(if(condicion)\n\tcondicion_true\n\tcondicion_false\n)",
                "3": "\t\t\tC\nSELECCIÓN MÚLTIPLE:\nPara seleccionar de manera múltiple se usa el switch-Case, dos palabras reservadas que de acuerdo al valor de una variable analizan n posibilidades distintas, también existe la posibilidad de asignar instrucciones cuando la variable no toma ningun valor dentro de los posibles casos.\nCada uno de los casos debe tener la palabra reservada: break para garantizar la salida de la estructura.\nSintácticamente:\nswitch(variable){\n\tCase 1: Opcion1\n\tCase 2: Opcion2\n\t.\n\tCase N: OpcionN\n\t.\n\tdefault: Opcion_por_defecto\n}\n\nSELECCIÓN SIMPLE:\nLa sentencia if evalua una condición escrita entre paréntesis y ejecuta la siguiente instrucción o conjunto de instrucciones.\nSintácticamente:\nif(condicion){\n\tBloque instrucciones\n}"
            }
        },

        "ciclos":
        {
            "1" : 
            {
                "1": "En este ejemplo se usa:\n\tEstructura de iteración: FOR",
                "2": "\t\t\tRACKET\nFOR:\nSe usa una variable para la cual se establece un rango de iteración. Se escribe la palabra reservada in-range y se coloca el inicio, el límite y la manera en que aumenta. Se separan por espacios en blanco.\nSintácticamente: \nfor(i (in-range inicio limite aumento))",
                "3": "\t\t\tC\nFOR:\nSe usa una variable (i) para la cual se establece un inicio, límite y la manera en que aumenta. Se separan por punto y coma ; \nSintácticamente:\nfor(i=inicio; i<limite; i++){\n\tCuerpo de Bucle\n\t}"
            },
            "2" : 
            {
                "1": "En este ejemplo se usa:\n\tEstructura de iteración: FOR",
                "2": "\t\t\tRACKET\nFOR:\nSe usa una variable para la cual se establece un rango de iteración. Se escribe la palabra reservada in-range y se coloca el inicio, el límite y la manera en que aumenta. Se separan por espacios en blanco.\nSintácticamente: \nfor(i (in-range inicio limite aumento))",
                "3": "\t\t\tC\nFOR:\nSe usa una variable (i) para la cual se establece un inicio, límite y la manera en que aumenta. Se separan por punto y coma ; \nSintácticamente:\nfor(i=inicio; i<limite; i++){\n\tCuerpo de Bucle\n\t}"
            },
            "3" : 
            {
                "1": "En este ejemplo se usa:\n\tEstructura de iteración: WHILE\n\tCondicional Simple: IF",
                "2": "\t\t\tRACKET\n\nWHILE:\nLa estructura de iteración while repite un conjunto de instrucciones siempre y cuando una condición se cumpla.\nSintácticamnete, se escribe entre paréntesis se escribe la palabra reservada while y luego la condición a evaluar. La condición como todas las expresiones en racket, se debe escribir en Pre-Orden.\nAsí:\n(while (< i 1)\nInstrucciones\n)\n\nSELECCIÓN SIMPLE:\nLa sentencia if analiza una condición escrita entre paréntesis, en caso de ser verdadera ejecuta la primera sentencia, sino, ejecuta la segunda.\nSintácticamente:\n(if(condicion)\n\tcondicion_true\n\tcondicion_false\n)",
                "3": "\t\t\tC\n\nWHILE:\nLa estructura repetitiva While se usa para repetir un conjunto de instrucciones siempre y cuando una condición se cumpla.\nA nivel de sintaxis se escribe la palabra reservada while y entre paréntesis la condición a evaluar, así:\nwhile(condicion_de_finalizacion){\n\tInstrucciones\n}\n\nSELECCIÓN SIMPLE:\nLa sentencia if evalua una condición escrita entre paréntesis y ejecuta la siguiente instrucción o conjunto de instrucciones.\nSintácticamente:\nif(condicion){\n\tBloque instrucciones\n}"
            },
            "4" : 
            {
                "1": "En este ejemplo se usa:\n\tEstructura de iteración: WHILE",
                "2": "\t\t\tRACKET\n\nWHILE:\nLa estructura de iteración while repite un conjunto de instrucciones siempre y cuando una condición se cumpla.\nSintácticamnete, se escribe entre paréntesis se escribe la palabra reservada while y luego la condición a evaluar. La condición como todas las expresiones en racket, se debe escribir en Pre-Orden.\nAsí:\n(while (< i 1)\nInstrucciones\n)",
                "3": "\t\t\tC\n\nWHILE:\nLa estructura repetitiva While se usa para repetir un conjunto de instrucciones siempre y cuando una condición se cumpla.\nA nivel de sintaxis se escribe la palabra reservada while y entre paréntesis la condición a evaluar, así:\nwhile(condicion_de_finalizacion){\n\tInstrucciones\n}"
            },
            "5" : 
            {
                "1": "En este ejemplo se usa:\n\tEstructura de iteración: DO (Racket) / DO WHILE (C)",
                "2": "\t\t\tRACKET\nDO:\nLa estructura repetitiva que ejecuta instrucciones y luego evalua en Racket se define por la palabra reservada do, sintácticamnete se coloca entre paréntesis la palabra do y se usa una variable para la cual se establece un inicio, la manera como incrementa y un límite.\nSintácticamnete:\nSea v la variable a iterar: \n(d (v inicio (+ v incremento)) (< v limite)\n\tInstrucciones\n))",
                "3": "\t\t\tC\nDO WHILE:\nEn C, la estructura repetitiva que ejecuta instrucciones y luego evalua se llama do-while. Se usa las palabras reservadas do y while, y entre corchetes se escribe las instrucciones a repetir, se finaliza con ;\nSintácticamente:\ndo{\n\tInstrucciones\n}while(condicion);"
            },
            "6" : 
            {
                "1": "En este ejemplo se usa:\n\tEstructura de iteración: DO (Racket) / DO WHILE (C)\n\tEstructura de iteración: WHILE",
                "2": "\t\t\tRACKET\nDO:\nLa estructura repetitiva que ejecuta instrucciones y luego evalua en Racket se define por la palabra reservada do, sintácticamnete se coloca entre paréntesis la palabra do y se usa una variable para la cual se establece un inicio, la manera como incrementa y un límite.\nSintácticamnete:\nSea v la variable a iterar: \n(d (v inicio (+ v incremento)) (< v limite)\n\tInstrucciones\n))\n\nWHILE:\nLa estructura de iteración while repite un conjunto de instrucciones siempre y cuando una condición se cumpla.\nSintácticamnete, se escribe entre paréntesis se escribe la palabra reservada while y luego la condición a evaluar. La condición como todas las expresiones en racket, se debe escribir en Pre-Orden.\nAsí:\n(while (< i 1)\nInstrucciones\n)",
                "3": "\t\t\tC\nDO WHILE:\nEn C, la estructura repetitiva que ejecuta instrucciones y luego evalua se llama do-while. Se usa las palabras reservadas do y while, y entre corchetes se escribe las instrucciones a repetir, se finaliza con ;\nSintácticamente:\ndo{\n\tInstrucciones\n}while(condicion);\n\nWHILE:\nLa estructura repetitiva While se usa para repetir un conjunto de instrucciones siempre y cuando una condición se cumpla.\nA nivel de sintaxis se escribe la palabra reservada while y entre paréntesis la condición a evaluar, así:\nwhile(condicion_de_finalizacion){\n\tInstrucciones\n}"
            }
        },

        "cadenas":
        {
            "1" : 
            {
                "1": "En este ejemplo se usa:\n\tCadenas",
                "2": "\t\t\tRACKET\nCADENAS:\nLas cadenas en Racket se definen como cualquier otra variable, se usa la palabra define y un identificador o nombre para dicha variable, seguidamente se inicializa la cadena entre comillas dobles \"\".\nSintácticamnete: \n(define cadena1 \"\")\n(define cadena2 \"Hola Mundo\")\n\nFunciones para cadenas:\n En Racket las funciones para el manejo de cadenas vienen nativas con el lenguaje, es decir, no hay que importar módulos o librerías.",
                "3": "\t\t\tC\nCADENAS:\nLas cadenas en C son un tipo de dato de char, solo que no almacena un solo caracter, sino que almacena varios caracteres en una sola variable, por lo que a nivel de sintaxis una cadena se declara así:\nchar cadena[]\nEs opcional ponerle el tamaño a la cadena, depende si se inicializa en el momento o no.\n*El caso especial para capturar cadenas por consola es que no se usa el ampersand & a la hora de colocar el nombre de la variable.\n\nFunciones para cadenas:\n En C existen librerías que permiten el manejo de funciones (copiar, concatenar, comparar, etc.) estas funciones se usan importando la librería: string.h "
            },
            "2" : 
            {
                "1": "En este ejemplo se usa:\n\tCadenas\n\tEstructura de iteración: FOR",
                "2": "\t\t\tRACKET\nCADENAS:\nLas cadenas en Racket se definen como cualquier otra variable, se usa la palabra define y un identificador o nombre para dicha variable, seguidamente se inicializa la cadena entre comillas dobles \"\".\nSintácticamnete: \n(define cadena1 \"\")\n(define cadena2 \"Hola Mundo\")\n\nFunciones para cadenas:\n En Racket las funciones para el manejo de cadenas vienen nativas con el lenguaje, es decir, no hay que importar módulos o librerías.\n\nFOR:\nSe usa una variable para la cual se establece un rango de iteración. Se escribe la palabra reservada in-range y se coloca el inicio, el límite y la manera en que aumenta. Se separan por espacios en blanco.\nSintácticamente: \nfor(i (in-range inicio limite aumento))",
                "3": "\t\t\tC\nCADENAS:\nLas cadenas en C son un tipo de dato de char, solo que no almacena un solo caracter, sino que almacena varios caracteres en una sola variable, por lo que a nivel de sintaxis una cadena se declara así:\nchar cadena[]\nEs opcional ponerle el tamaño a la cadena, depende si se inicializa en el momento o no.\n*El caso especial para capturar cadenas por consola es que no se usa el ampersand & a la hora de colocar el nombre de la variable.\n\nFunciones para cadenas:\n En C existen librerías que permiten el manejo de funciones (copiar, concatenar, comparar, etc.) estas funciones se usan importando la librería: string.h \n\nFOR:\nSe usa una variable (i) para la cual se establece un inicio, límite y la manera en que aumenta. Se separan por punto y coma ; \nSintácticamente:\nfor(i=inicio; i<limite; i++){\n\tCuerpo de Bucle\n\t}"
            },
            "3" : 
            {
                "1": "En este ejemplo se usa:\n\tCadenas\n\tEstructura de iteración: FOR\n\tCondicional Simple: IF",
                "2": "\t\t\tRACKET\nCADENAS:\nLas cadenas en Racket se definen como cualquier otra variable, se usa la palabra define y un identificador o nombre para dicha variable, seguidamente se inicializa la cadena entre comillas dobles \"\".\nSintácticamnete: \n(define cadena1 \"\")\n(define cadena2 \"Hola Mundo\")\n\nFunciones para cadenas:\n En Racket las funciones para el manejo de cadenas vienen nativas con el lenguaje, es decir, no hay que importar módulos o librerías.\n\nFOR:\nSe usa una variable para la cual se establece un rango de iteración. Se escribe la palabra reservada in-range y se coloca el inicio, el límite y la manera en que aumenta. Se separan por espacios en blanco.\nSintácticamente: \nfor(i (in-range inicio limite aumento))\n\nSELECCIÓN SIMPLE:\nLa sentencia if analiza una condición escrita entre paréntesis, en caso de ser verdadera ejecuta la primera sentencia, sino, ejecuta la segunda.\nSintácticamente:\n(if(condicion)\n\tcondicion_true\n\tcondicion_false\n)",
                "3": "\t\t\tC\nCADENAS:\nLas cadenas en C son un tipo de dato de char, solo que no almacena un solo caracter, sino que almacena varios caracteres en una sola variable, por lo que a nivel de sintaxis una cadena se declara así:\nchar cadena[]\nEs opcional ponerle el tamaño a la cadena, depende si se inicializa en el momento o no.\n*El caso especial para capturar cadenas por consola es que no se usa el ampersand & a la hora de colocar el nombre de la variable.\n\nFunciones para cadenas:\n En C existen librerías que permiten el manejo de funciones (copiar, concatenar, comparar, etc.) estas funciones se usan importando la librería: string.h \n\nFOR:\nSe usa una variable (i) para la cual se establece un inicio, límite y la manera en que aumenta. Se separan por punto y coma ; \nSintácticamente:\nfor(i=inicio; i<limite; i++){\n\tCuerpo de Bucle\n\t}\n\nSELECCIÓN SIMPLE:\nLa sentencia if evalua una condición escrita entre paréntesis y ejecuta la siguiente instrucción o conjunto de instrucciones.\nSintácticamente:\nif(condicion){\n\tBloque instrucciones\n}"
            },
            "4" : 
            {
                "1": "En este ejemplo se usa:\n\tCadenas\n\tEstructura de iteración: FOR\n\tCondicional Simple: IF",
                "2": "\t\t\tRACKET\nCADENAS:\nLas cadenas en Racket se definen como cualquier otra variable, se usa la palabra define y un identificador o nombre para dicha variable, seguidamente se inicializa la cadena entre comillas dobles \"\".\nSintácticamnete: \n(define cadena1 \"\")\n(define cadena2 \"Hola Mundo\")\n\nFunciones para cadenas:\n En Racket las funciones para el manejo de cadenas vienen nativas con el lenguaje, es decir, no hay que importar módulos o librerías.\n\nFOR:\nSe usa una variable para la cual se establece un rango de iteración. Se escribe la palabra reservada in-range y se coloca el inicio, el límite y la manera en que aumenta. Se separan por espacios en blanco.\nSintácticamente: \nfor(i (in-range inicio limite aumento))\n\nSELECCIÓN SIMPLE:\nLa sentencia if analiza una condición escrita entre paréntesis, en caso de ser verdadera ejecuta la primera sentencia, sino, ejecuta la segunda.\nSintácticamente:\n(if(condicion)\n\tcondicion_true\n\tcondicion_false\n)",
                "3": "\t\t\tC\nCADENAS:\nLas cadenas en C son un tipo de dato de char, solo que no almacena un solo caracter, sino que almacena varios caracteres en una sola variable, por lo que a nivel de sintaxis una cadena se declara así:\nchar cadena[]\nEs opcional ponerle el tamaño a la cadena, depende si se inicializa en el momento o no.\n*El caso especial para capturar cadenas por consola es que no se usa el ampersand & a la hora de colocar el nombre de la variable.\n\nFunciones para cadenas:\n En C existen librerías que permiten el manejo de funciones (copiar, concatenar, comparar, etc.) estas funciones se usan importando la librería: string.h \n\nFOR:\nSe usa una variable (i) para la cual se establece un inicio, límite y la manera en que aumenta. Se separan por punto y coma ; \nSintácticamente:\nfor(i=inicio; i<limite; i++){\n\tCuerpo de Bucle\n\t}\n\nSELECCIÓN SIMPLE:\nLa sentencia if evalua una condición escrita entre paréntesis y ejecuta la siguiente instrucción o conjunto de instrucciones.\nSintácticamente:\nif(condicion){\n\tBloque instrucciones\n}"
            },
            "5" : 
            {
                "1": "En este ejemplo se usa:\n\tCadenas\n\tEstructura de iteración: FOR\n\tCondicional Simple: IF",
                "2": "\t\t\tRACKET\nCADENAS:\nLas cadenas en Racket se definen como cualquier otra variable, se usa la palabra define y un identificador o nombre para dicha variable, seguidamente se inicializa la cadena entre comillas dobles \"\".\nSintácticamnete: \n(define cadena1 \"\")\n(define cadena2 \"Hola Mundo\")\n\nFunciones para cadenas:\n En Racket las funciones para el manejo de cadenas vienen nativas con el lenguaje, es decir, no hay que importar módulos o librerías.\n\nFOR:\nSe usa una variable para la cual se establece un rango de iteración. Se escribe la palabra reservada in-range y se coloca el inicio, el límite y la manera en que aumenta. Se separan por espacios en blanco.\nSintácticamente: \nfor(i (in-range inicio limite aumento))\n\nSELECCIÓN SIMPLE:\nLa sentencia if analiza una condición escrita entre paréntesis, en caso de ser verdadera ejecuta la primera sentencia, sino, ejecuta la segunda.\nSintácticamente:\n(if(condicion)\n\tcondicion_true\n\tcondicion_false\n)",
                "3": "\t\t\tC\nCADENAS:\nLas cadenas en C son un tipo de dato de char, solo que no almacena un solo caracter, sino que almacena varios caracteres en una sola variable, por lo que a nivel de sintaxis una cadena se declara así:\nchar cadena[]\nEs opcional ponerle el tamaño a la cadena, depende si se inicializa en el momento o no.\n*El caso especial para capturar cadenas por consola es que no se usa el ampersand & a la hora de colocar el nombre de la variable.\n\nFunciones para cadenas:\n En C existen librerías que permiten el manejo de funciones (copiar, concatenar, comparar, etc.) estas funciones se usan importando la librería: string.h \n\nFOR:\nSe usa una variable (i) para la cual se establece un inicio, límite y la manera en que aumenta. Se separan por punto y coma ; \nSintácticamente:\nfor(i=inicio; i<limite; i++){\n\tCuerpo de Bucle\n\t}\n\nSELECCIÓN SIMPLE:\nLa sentencia if evalua una condición escrita entre paréntesis y ejecuta la siguiente instrucción o conjunto de instrucciones.\nSintácticamente:\nif(condicion){\n\tBloque instrucciones\n}"
            },
            "6" : 
            {
                "1": "En este ejemplo se usa:\n\tCadenas",
                "2": "\t\t\tRACKET\nCADENAS:\nLas cadenas en Racket se definen como cualquier otra variable, se usa la palabra define y un identificador o nombre para dicha variable, seguidamente se inicializa la cadena entre comillas dobles \"\".\nSintácticamnete: \n(define cadena1 \"\")\n(define cadena2 \"Hola Mundo\")\n\nFunciones para cadenas:\n En Racket las funciones para el manejo de cadenas vienen nativas con el lenguaje, es decir, no hay que importar módulos o librerías.",
                "3": "\t\t\tC\nCADENAS:\nLas cadenas en C son un tipo de dato de char, solo que no almacena un solo caracter, sino que almacena varios caracteres en una sola variable, por lo que a nivel de sintaxis una cadena se declara así:\nchar cadena[]\nEs opcional ponerle el tamaño a la cadena, depende si se inicializa en el momento o no.\n*El caso especial para capturar cadenas por consola es que no se usa el ampersand & a la hora de colocar el nombre de la variable.\n\nFunciones para cadenas:\n En C existen librerías que permiten el manejo de funciones (copiar, concatenar, comparar, etc.) estas funciones se usan importando la librería: string.h "
            }
        },

        "vectores":
        {
            "1" : 
            {
                "1": "En este ejemplo se usa:\n\tVectores\n\tEstructura de iteración: FOR",
                "2": "\t\t\tRACKET\nVECTORES:\nPara definir un vector en Racket, se usa la palabra reservada vector o make-vector y entre paréntesis se inicializan.\nLos vectores también se les tiene que definir un nombre, así que: \n(define vec (vector 1 2 3))\n\nFOR:\nSe usa una variable para la cual se establece un rango de iteración. Se escribe la palabra reservada in-range y se coloca el inicio, el límite y la manera en que aumenta. Se separan por espacios en blanco.\nSintácticamente: \nfor(i (in-range inicio limite aumento))",
                "3": "\t\t\tC\nVECTORES:\nLos vectores en C se declaran teniendo en cuenta:\n\tTipo de dato\n\tNombre\n\tTamaño.\nSintacticamente:\n tipo_dato nombre_vector[tamaño_vector];\n\nFOR:\nSe usa una variable (i) para la cual se establece un inicio, límite y la manera en que aumenta. Se separan por punto y coma ; \nSintácticamente:\nfor(i=inicio; i<limite; i++){\n\tCuerpo de Bucle\n\t}"
            },
            "2" : 
            {
                "1": "En este ejemplo se usa:\n\tVectores\n\tEstructura de iteración: FOR",
                "2": "\t\t\tRACKET\nVECTORES:\nPara definir un vector en Racket, se usa la palabra reservada vector o make-vector y entre paréntesis se inicializan.\nLos vectores también se les tiene que definir un nombre, así que: \n(define vec (vector 1 2 3))\n\nFOR:\nSe usa una variable para la cual se establece un rango de iteración. Se escribe la palabra reservada in-range y se coloca el inicio, el límite y la manera en que aumenta. Se separan por espacios en blanco.\nSintácticamente: \nfor(i (in-range inicio limite aumento))",
                "3": "\t\t\tC\nVECTORES:\nLos vectores en C se declaran teniendo en cuenta:\n\tTipo de dato\n\tNombre\n\tTamaño.\nSintacticamente:\n tipo_dato nombre_vector[tamaño_vector];\n\nFOR:\nSe usa una variable (i) para la cual se establece un inicio, límite y la manera en que aumenta. Se separan por punto y coma ; \nSintácticamente:\nfor(i=inicio; i<limite; i++){\n\tCuerpo de Bucle\n\t}"
            },
            "3" : 
            {
                "1": "En este ejemplo se usa:\n\tVectores\n\tEstructura de iteración: FOR",
                "2": "\t\t\tRACKET\nVECTORES:\nPara definir un vector en Racket, se usa la palabra reservada vector o make-vector y entre paréntesis se inicializan.\nLos vectores también se les tiene que definir un nombre, así que: \n(define vec (vector 1 2 3))\n\nFOR:\nSe usa una variable para la cual se establece un rango de iteración. Se escribe la palabra reservada in-range y se coloca el inicio, el límite y la manera en que aumenta. Se separan por espacios en blanco.\nSintácticamente: \nfor(i (in-range inicio limite aumento))",
                "3": "\t\t\tC\nVECTORES:\nLos vectores en C se declaran teniendo en cuenta:\n\tTipo de dato\n\tNombre\n\tTamaño.\nSintacticamente:\n tipo_dato nombre_vector[tamaño_vector];\n\nFOR:\nSe usa una variable (i) para la cual se establece un inicio, límite y la manera en que aumenta. Se separan por punto y coma ; \nSintácticamente:\nfor(i=inicio; i<limite; i++){\n\tCuerpo de Bucle\n\t}"
            },
            "4" : 
            {
                "1": "En este ejemplo se usa:\n\tVectores\n\tEstructura de iteración: FOR",
                "2": "\t\t\tRACKET\nVECTORES:\nPara definir un vector en Racket, se usa la palabra reservada vector o make-vector y entre paréntesis se inicializan.\nLos vectores también se les tiene que definir un nombre, así que: \n(define vec (vector 1 2 3))\n\nFOR:\nSe usa una variable para la cual se establece un rango de iteración. Se escribe la palabra reservada in-range y se coloca el inicio, el límite y la manera en que aumenta. Se separan por espacios en blanco.\nSintácticamente: \nfor(i (in-range inicio limite aumento))",
                "3": "\t\t\tC\nVECTORES:\nLos vectores en C se declaran teniendo en cuenta:\n\tTipo de dato\n\tNombre\n\tTamaño.\nSintacticamente:\n tipo_dato nombre_vector[tamaño_vector];\n\nFOR:\nSe usa una variable (i) para la cual se establece un inicio, límite y la manera en que aumenta. Se separan por punto y coma ; \nSintácticamente:\nfor(i=inicio; i<limite; i++){\n\tCuerpo de Bucle\n\t}"
            },
            "5" : 
            {
                "1": "En este ejemplo se usa:\n\tVectores\n\tEstructura de iteración: FOR\n\tCondicional Simple: IF ",
                "2": "\t\t\tRACKET\nVECTORES:\nPara definir un vector en Racket, se usa la palabra reservada vector o make-vector y entre paréntesis se inicializan.\nLos vectores también se les tiene que definir un nombre, así que: \n(define vec (vector 1 2 3))\n\nFOR:\nSe usa una variable para la cual se establece un rango de iteración. Se escribe la palabra reservada in-range y se coloca el inicio, el límite y la manera en que aumenta. Se separan por espacios en blanco.\nSintácticamente: \nfor(i (in-range inicio limite aumento))\n\nSELECCIÓN SIMPLE:\nLa sentencia if analiza una condición escrita entre paréntesis, en caso de ser verdadera ejecuta la primera sentencia, sino, ejecuta la segunda.\nSintácticamente:\n(if(condicion)\n\tcondicion_true\n\tcondicion_false\n)",
                "3": "\t\t\tC\nVECTORES:\nLos vectores en C se declaran teniendo en cuenta:\n\tTipo de dato\n\tNombre\n\tTamaño.\nSintacticamente:\n tipo_dato nombre_vector[tamaño_vector];\n\nFOR:\nSe usa una variable (i) para la cual se establece un inicio, límite y la manera en que aumenta. Se separan por punto y coma ; \nSintácticamente:\nfor(i=inicio; i<limite; i++){\n\tCuerpo de Bucle\n\t}\n\nSELECCIÓN SIMPLE:\nLa sentencia if evalua una condición escrita entre paréntesis y ejecuta la siguiente instrucción o conjunto de instrucciones.\nSintácticamente:\nif(condicion){\n\tBloque instrucciones\n}"
            },
            "6" : 
            {
                "1": "En este ejemplo se usa:\n\tVectores\n\tEstructura de iteración: FOR\n\tCondicional Simple: IF ",
                "2": "\t\t\tRACKET\nVECTORES:\nPara definir un vector en Racket, se usa la palabra reservada vector o make-vector y entre paréntesis se inicializan.\nLos vectores también se les tiene que definir un nombre, así que: \n(define vec (vector 1 2 3))\n\nFOR:\nSe usa una variable para la cual se establece un rango de iteración. Se escribe la palabra reservada in-range y se coloca el inicio, el límite y la manera en que aumenta. Se separan por espacios en blanco.\nSintácticamente: \nfor(i (in-range inicio limite aumento))\n\nSELECCIÓN SIMPLE:\nLa sentencia if analiza una condición escrita entre paréntesis, en caso de ser verdadera ejecuta la primera sentencia, sino, ejecuta la segunda.\nSintácticamente:\n(if(condicion)\n\tcondicion_true\n\tcondicion_false\n)",
                "3": "\t\t\tC\nVECTORES:\nLos vectores en C se declaran teniendo en cuenta:\n\tTipo de dato\n\tNombre\n\tTamaño.\nSintacticamente:\n tipo_dato nombre_vector[tamaño_vector];\n\nFOR:\nSe usa una variable (i) para la cual se establece un inicio, límite y la manera en que aumenta. Se separan por punto y coma ; \nSintácticamente:\nfor(i=inicio; i<limite; i++){\n\tCuerpo de Bucle\n\t}\n\nSELECCIÓN SIMPLE:\nLa sentencia if evalua una condición escrita entre paréntesis y ejecuta la siguiente instrucción o conjunto de instrucciones.\nSintácticamente:\nif(condicion){\n\tBloque instrucciones\n}"
            }
        },

        "matrices":
        {
            "1" : 
            {
                "1": "En este ejemplo se usa:\n\tMatrices\n\tEstructura de iteración: FOR",
                "2": "\t\t\tRACKET\nMATRICES:\nPara el manejo de matrices en racket es necesario importar o requerir el módulo math/matrix\nDicho módulo contiene funciones para crear y llenar matrices.\nLas matrices se definen como una variable más en Racket, se usa la palabra define y se le da un identificador.\nSintácticamente:\n(require math/matrix)\n(define matriz (make-matrix fil col 0))\n\nFOR:\nSe usa una variable para la cual se establece un rango de iteración. Se escribe la palabra reservada in-range y se coloca el inicio, el límite y la manera en que aumenta. Se separan por espacios en blanco.\nSintácticamente: \nfor(i (in-range inicio limite aumento))",
                "3": "\t\t\tC\nMATRICES:\nLas matrices en C se consideran un vector bidimensional, por lo que se declaran de igual manera, solo que en vez de proporcionar un tamaño, se proporciona un número de alto y ancho, para las filas y columnas respectivamente, así que hablando sintácticamente:\ntipo_dato nombre_matriz[filas][Columnas];\n\nFOR:\nSe usa una variable (i) para la cual se establece un inicio, límite y la manera en que aumenta. Se separan por punto y coma ; \nSintácticamente:\nfor(i=inicio; i<limite; i++){\n\tCuerpo de Bucle\n\t}"
            },
            "2" : 
            {
                "1": "En este ejemplo se usa:\n\tMatrices\n\tEstructura de iteración: FOR",
                "2": "\t\t\tRACKET\nMATRICES:\nPara el manejo de matrices en racket es necesario importar o requerir el módulo math/matrix\nDicho módulo contiene funciones para crear y llenar matrices.\nLas matrices se definen como una variable más en Racket, se usa la palabra define y se le da un identificador.\nSintácticamente:\n(require math/matrix)\n(define matriz (make-matrix fil col 0))\n\nFOR:\nSe usa una variable para la cual se establece un rango de iteración. Se escribe la palabra reservada in-range y se coloca el inicio, el límite y la manera en que aumenta. Se separan por espacios en blanco.\nSintácticamente: \nfor(i (in-range inicio limite aumento))",
                "3": "\t\t\tC\nMATRICES:\nLas matrices en C se consideran un vector bidimensional, por lo que se declaran de igual manera, solo que en vez de proporcionar un tamaño, se proporciona un número de alto y ancho, para las filas y columnas respectivamente, así que hablando sintácticamente:\ntipo_dato nombre_matriz[filas][Columnas];\n\nFOR:\nSe usa una variable (i) para la cual se establece un inicio, límite y la manera en que aumenta. Se separan por punto y coma ; \nSintácticamente:\nfor(i=inicio; i<limite; i++){\n\tCuerpo de Bucle\n\t}"
            },
            "3" : 
            {
                "1": "En este ejemplo se usa:\n\tMatrices\n\tEstructura de iteración: FOR",
                "2": "\t\t\tRACKET\nMATRICES:\nPara el manejo de matrices en racket es necesario importar o requerir el módulo math/matrix\nDicho módulo contiene funciones para crear y llenar matrices.\nLas matrices se definen como una variable más en Racket, se usa la palabra define y se le da un identificador.\nSintácticamente:\n(require math/matrix)\n(define matriz (make-matrix fil col 0))\n\nFOR:\nSe usa una variable para la cual se establece un rango de iteración. Se escribe la palabra reservada in-range y se coloca el inicio, el límite y la manera en que aumenta. Se separan por espacios en blanco.\nSintácticamente: \nfor(i (in-range inicio limite aumento))",
                "3": "\t\t\tC\nMATRICES:\nLas matrices en C se consideran un vector bidimensional, por lo que se declaran de igual manera, solo que en vez de proporcionar un tamaño, se proporciona un número de alto y ancho, para las filas y columnas respectivamente, así que hablando sintácticamente:\ntipo_dato nombre_matriz[filas][Columnas];\n\nFOR:\nSe usa una variable (i) para la cual se establece un inicio, límite y la manera en que aumenta. Se separan por punto y coma ; \nSintácticamente:\nfor(i=inicio; i<limite; i++){\n\tCuerpo de Bucle\n\t}"
            },
            "4" : 
            {
                "1": "En este ejemplo se usa:\n\tMatrices\n\tEstructura de iteración: FOR",
                "2": "\t\t\tRACKET\nMATRICES:\nPara el manejo de matrices en racket es necesario importar o requerir el módulo math/matrix\nDicho módulo contiene funciones para crear y llenar matrices.\nLas matrices se definen como una variable más en Racket, se usa la palabra define y se le da un identificador.\nSintácticamente:\n(require math/matrix)\n(define matriz (make-matrix fil col 0))\n\nFOR:\nSe usa una variable para la cual se establece un rango de iteración. Se escribe la palabra reservada in-range y se coloca el inicio, el límite y la manera en que aumenta. Se separan por espacios en blanco.\nSintácticamente: \nfor(i (in-range inicio limite aumento))",
                "3": "\t\t\tC\nMATRICES:\nLas matrices en C se consideran un vector bidimensional, por lo que se declaran de igual manera, solo que en vez de proporcionar un tamaño, se proporciona un número de alto y ancho, para las filas y columnas respectivamente, así que hablando sintácticamente:\ntipo_dato nombre_matriz[filas][Columnas];\n\nFOR:\nSe usa una variable (i) para la cual se establece un inicio, límite y la manera en que aumenta. Se separan por punto y coma ; \nSintácticamente:\nfor(i=inicio; i<limite; i++){\n\tCuerpo de Bucle\n\t}"
            },
            "5" : 
            {
                "1": "En este ejemplo se usa:\n\tMatrices\n\tEstructura de iteración: FOR\n\tCondicional Simple: IF",
                "2": "\t\t\tRACKET\nMATRICES:\nPara el manejo de matrices en racket es necesario importar o requerir el módulo math/matrix\nDicho módulo contiene funciones para crear y llenar matrices.\nLas matrices se definen como una variable más en Racket, se usa la palabra define y se le da un identificador.\nSintácticamente:\n(require math/matrix)\n(define matriz (make-matrix fil col 0))\n\nFOR:\nSe usa una variable para la cual se establece un rango de iteración. Se escribe la palabra reservada in-range y se coloca el inicio, el límite y la manera en que aumenta. Se separan por espacios en blanco.\nSintácticamente: \nfor(i (in-range inicio limite aumento))\n\nSELECCIÓN SIMPLE:\nLa sentencia if analiza una condición escrita entre paréntesis, en caso de ser verdadera ejecuta la primera sentencia, sino, ejecuta la segunda.\nSintácticamente:\n(if(condicion)\n\tcondicion_true\n\tcondicion_false\n)",
                "3": "\t\t\tC\nMATRICES:\nLas matrices en C se consideran un vector bidimensional, por lo que se declaran de igual manera, solo que en vez de proporcionar un tamaño, se proporciona un número de alto y ancho, para las filas y columnas respectivamente, así que hablando sintácticamente:\ntipo_dato nombre_matriz[filas][Columnas];\n\nFOR:\nSe usa una variable (i) para la cual se establece un inicio, límite y la manera en que aumenta. Se separan por punto y coma ; \nSintácticamente:\nfor(i=inicio; i<limite; i++){\n\tCuerpo de Bucle\n\t}\n\nSELECCIÓN SIMPLE:\nLa sentencia if evalua una condición escrita entre paréntesis y ejecuta la siguiente instrucción o conjunto de instrucciones.\nSintácticamente:\nif(condicion){\n\tBloque instrucciones\n}"
            },
            "6" : 
            {
                "1": "En este ejemplo se usa:\n\tMatrices\n\tEstructura de iteración: FOR\n\tCondicional Simple: IF\n\tEstructura de iteración: DO (Racket) / DO WHILE (C)",
                "2": "\t\t\tRACKET\nMATRICES:\nPara el manejo de matrices en racket es necesario importar o requerir el módulo math/matrix\nDicho módulo contiene funciones para crear y llenar matrices.\nLas matrices se definen como una variable más en Racket, se usa la palabra define y se le da un identificador.\nSintácticamente:\n(require math/matrix)\n(define matriz (make-matrix fil col 0))\n\nFOR:\nSe usa una variable para la cual se establece un rango de iteración. Se escribe la palabra reservada in-range y se coloca el inicio, el límite y la manera en que aumenta. Se separan por espacios en blanco.\nSintácticamente: \nfor(i (in-range inicio limite aumento))\n\nSELECCIÓN SIMPLE:\nLa sentencia if analiza una condición escrita entre paréntesis, en caso de ser verdadera ejecuta la primera sentencia, sino, ejecuta la segunda.\nSintácticamente:\n(if(condicion)\n\tcondicion_true\n\tcondicion_false\n)\n\nDO:\nLa estructura repetitiva que ejecuta instrucciones y luego evalua en Racket se define por la palabra reservada do, sintácticamnete se coloca entre paréntesis la palabra do y se usa una variable para la cual se establece un inicio, la manera como incrementa y un límite.\nSintácticamnete:\nSea v la variable a iterar: \n(d (v inicio (+ v incremento)) (< v limite)\n\tInstrucciones\n))",
                "3": "\t\t\tC\nMATRICES:\nLas matrices en C se consideran un vector bidimensional, por lo que se declaran de igual manera, solo que en vez de proporcionar un tamaño, se proporciona un número de alto y ancho, para las filas y columnas respectivamente, así que hablando sintácticamente:\ntipo_dato nombre_matriz[filas][Columnas];\n\nFOR:\nSe usa una variable (i) para la cual se establece un inicio, límite y la manera en que aumenta. Se separan por punto y coma ; \nSintácticamente:\nfor(i=inicio; i<limite; i++){\n\tCuerpo de Bucle\n\t}\n\nSELECCIÓN SIMPLE:\nLa sentencia if evalua una condición escrita entre paréntesis y ejecuta la siguiente instrucción o conjunto de instrucciones.\nSintácticamente:\nif(condicion){\n\tBloque instrucciones\n}\n\nDO WHILE:\nEn C, la estructura repetitiva que ejecuta instrucciones y luego evalua se llama do-while. Se usa las palabras reservadas do y while, y entre corchetes se escribe las instrucciones a repetir, se finaliza con ;\nSintácticamente:\ndo{\n\tInstrucciones\n}while(condicion);"
            }
        },

        "estructuras":
        {
            "1" : 
            {
                "1": "En este ejemplo se usa:\n\tEstructuras",
                "2": "\t\t\tRACKET\nESTRUCTURAS\nPara definir una estructura en Racket se usa un caso especial de la palabra reservada define. Se usa la palabra: define-struct y se le da un nombre para la estructura, seguidamente entre paréntesis se colocan las variables correspondientes a los miembros de la estructura.\nSintácticamnete:\n(define-struct nombre_estructura(\n\tmiembro_1\n\tmiembro_2\n\t)\n)",
                "3": "\t\t\tC\nESTRUCTURAS:\nEn C las estructuras se definen con la palabra reservada struct y entre llaves se ingresan todos los miembros de dicha estructura, cada miembro debe tener declarado su tipo de dato y su nombre. Una vez finalizado esto, luego de las llaves se puede realizar la creación de una variable del tipo de dicha estructura o simplemente colocar el símbolo ;\n\nSintacticamnete:\nstruct nombre_estructura{\n\tint numero;\n\tint vector[20]\n}variable_de_estrucutra;"
            },
            "2" : 
            {
                "1": "En este ejemplo se usa:\n\tEstructuras",
                "2": "\t\t\tRACKET\nESTRUCTURAS\nPara definir una estructura en Racket se usa un caso especial de la palabra reservada define. Se usa la palabra: define-struct y se le da un nombre para la estructura, seguidamente entre paréntesis se colocan las variables correspondientes a los miembros de la estructura.\nSintácticamnete:\n(define-struct nombre_estructura(\n\tmiembro_1\n\tmiembro_2\n\t)\n)",
                "3": "\t\t\tC\nESTRUCTURAS:\nEn C las estructuras se definen con la palabra reservada struct y entre llaves se ingresan todos los miembros de dicha estructura, cada miembro debe tener declarado su tipo de dato y su nombre. Una vez finalizado esto, luego de las llaves se puede realizar la creación de una variable del tipo de dicha estructura o simplemente colocar el símbolo ;\n\nSintacticamnete:\nstruct nombre_estructura{\n\tint numero;\n\tint vector[20]\n}variable_de_estrucutra;"
            },
            "3" : 
            {
                "1": "En este ejemplo se usa:\n\tEstructuras",
                "2": "\t\t\tRACKET\nESTRUCTURAS\nPara definir una estructura en Racket se usa un caso especial de la palabra reservada define. Se usa la palabra: define-struct y se le da un nombre para la estructura, seguidamente entre paréntesis se colocan las variables correspondientes a los miembros de la estructura.\nSintácticamnete:\n(define-struct nombre_estructura(\n\tmiembro_1\n\tmiembro_2\n\t)\n)",
                "3": "\t\t\tC\nESTRUCTURAS:\nEn C las estructuras se definen con la palabra reservada struct y entre llaves se ingresan todos los miembros de dicha estructura, cada miembro debe tener declarado su tipo de dato y su nombre. Una vez finalizado esto, luego de las llaves se puede realizar la creación de una variable del tipo de dicha estructura o simplemente colocar el símbolo ;\n\nSintacticamnete:\nstruct nombre_estructura{\n\tint numero;\n\tint vector[20]\n}variable_de_estrucutra;"
            },
            "4" : 
            {
                "1": "En este ejemplo se usa:\n\tEstructuras",
                "2": "\t\t\tRACKET\nESTRUCTURAS\nPara definir una estructura en Racket se usa un caso especial de la palabra reservada define. Se usa la palabra: define-struct y se le da un nombre para la estructura, seguidamente entre paréntesis se colocan las variables correspondientes a los miembros de la estructura.\nSintácticamnete:\n(define-struct nombre_estructura(\n\tmiembro_1\n\tmiembro_2\n\t)\n)",
                "3": "\t\t\tC\nESTRUCTURAS:\nEn C las estructuras se definen con la palabra reservada struct y entre llaves se ingresan todos los miembros de dicha estructura, cada miembro debe tener declarado su tipo de dato y su nombre. Una vez finalizado esto, luego de las llaves se puede realizar la creación de una variable del tipo de dicha estructura o simplemente colocar el símbolo ;\n\nSintacticamnete:\nstruct nombre_estructura{\n\tint numero;\n\tint vector[20]\n}variable_de_estrucutra;"
            },
            "5" : 
            {
                "1": "En este ejemplo se usa:\n\tEstructuras\n\tVectores",
                "2": "\t\t\tRACKET\nESTRUCTURAS\nPara definir una estructura en Racket se usa un caso especial de la palabra reservada define. Se usa la palabra: define-struct y se le da un nombre para la estructura, seguidamente entre paréntesis se colocan las variables correspondientes a los miembros de la estructura.\nSintácticamnete:\n(define-struct nombre_estructura(\n\tmiembro_1\n\tmiembro_2\n\t)\n)\n\nVECTORES:\nPara definir un vector en Racket, se usa la palabra reservada vector o make-vector y entre paréntesis se inicializan.\nLos vectores también se les tiene que definir un nombre, así que: \n(define vec (vector 1 2 3))",
                "3": "\t\t\tC\nESTRUCTURAS:\nEn C las estructuras se definen con la palabra reservada struct y entre llaves se ingresan todos los miembros de dicha estructura, cada miembro debe tener declarado su tipo de dato y su nombre. Una vez finalizado esto, luego de las llaves se puede realizar la creación de una variable del tipo de dicha estructura o simplemente colocar el símbolo ;\n\nSintacticamnete:\nstruct nombre_estructura{\n\tint numero;\n\tint vector[20]\n}variable_de_estrucutra;\n\nVECTORES:\nLos vectores en C se declaran teniendo en cuenta:\n\tTipo de dato\n\tNombre\n\tTamaño.\nSintacticamente:\n tipo_dato nombre_vector[tamaño_vector];"
            },
            "6" : 
            {
                "1": "En este ejemplo se usa:\n\tEstructuras\n\tVectores",
                "2": "\t\t\tRACKET\nESTRUCTURAS\nPara definir una estructura en Racket se usa un caso especial de la palabra reservada define. Se usa la palabra: define-struct y se le da un nombre para la estructura, seguidamente entre paréntesis se colocan las variables correspondientes a los miembros de la estructura.\nSintácticamnete:\n(define-struct nombre_estructura(\n\tmiembro_1\n\tmiembro_2\n\t)\n)\n\nVECTORES:\nPara definir un vector en Racket, se usa la palabra reservada vector o make-vector y entre paréntesis se inicializan.\nLos vectores también se les tiene que definir un nombre, así que: \n(define vec (vector 1 2 3))",
                "3": "\t\t\tC\nESTRUCTURAS:\nEn C las estructuras se definen con la palabra reservada struct y entre llaves se ingresan todos los miembros de dicha estructura, cada miembro debe tener declarado su tipo de dato y su nombre. Una vez finalizado esto, luego de las llaves se puede realizar la creación de una variable del tipo de dicha estructura o simplemente colocar el símbolo ;\n\nSintacticamnete:\nstruct nombre_estructura{\n\tint numero;\n\tint vector[20]\n}variable_de_estrucutra;\n\nVECTORES:\nLos vectores en C se declaran teniendo en cuenta:\n\tTipo de dato\n\tNombre\n\tTamaño.\nSintacticamente:\n tipo_dato nombre_vector[tamaño_vector];"
            }
        },

        "funciones":
        {
            "1" : 
            {
                "1": "En este ejemplo se usa:\n\tFunciones",
                "2": "\t\t\tRACKET\nFUNCIONES:\nEn Racket basta con escribir la palabra reservada define y seguido dar un nombre o identificador para la función, a continuación se escriben sus parametros y las instrucciones correspondientes.\nSintácticamente: (define nombre_funcion (num1 num2)\nInstrucciones\n)",
                "3": "\t\t\tC\nFUNCIONES:\nEn C el definir funciones es algo sencillo pero especifico, se debe tener en cuenta el tipo de dato que la función retornará y el tipo de dato de los parametros de entrada.\nSintácticamente:\n tipo_dato_salida nombre_funcion (tipo_dato_entrada entrada1, tipo_dato_entrada entrada2){\n\tInstrucciones\n}"
            },
            "2" : 
            {
                "1": "En este ejemplo se usa:\n\tFunciones",
                "2": "\t\t\tRACKET\nFUNCIONES:\nEn Racket basta con escribir la palabra reservada define y seguido dar un nombre o identificador para la función, a continuación se escriben sus parametros y las instrucciones correspondientes.\nSintácticamente: (define nombre_funcion (num1 num2)\nInstrucciones\n)",
                "3": "\t\t\tC\nFUNCIONES:\nEn C el definir funciones es algo sencillo pero especifico, se debe tener en cuenta el tipo de dato que la función retornará y el tipo de dato de los parametros de entrada.\nSintácticamente:\n tipo_dato_salida nombre_funcion (tipo_dato_entrada entrada1, tipo_dato_entrada entrada2){\n\tInstrucciones\n}"
            },
            "3" : 
            {
                "1": "En este ejemplo se usa:\n\tFunciones",
                "2": "\t\t\tRACKET\nFUNCIONES:\nEn Racket basta con escribir la palabra reservada define y seguido dar un nombre o identificador para la función, a continuación se escriben sus parametros y las instrucciones correspondientes.\nSintácticamente: (define nombre_funcion (num1 num2)\nInstrucciones\n)",
                "3": "\t\t\tC\nFUNCIONES:\nEn C el definir funciones es algo sencillo pero especifico, se debe tener en cuenta el tipo de dato que la función retornará y el tipo de dato de los parametros de entrada.\nSintácticamente:\n tipo_dato_salida nombre_funcion (tipo_dato_entrada entrada1, tipo_dato_entrada entrada2){\n\tInstrucciones\n}"
            },
            "4" : 
            {
                "1": "En este ejemplo se usa:\n\tFunciones",
                "2": "\t\t\tRACKET\nFUNCIONES:\nEn Racket basta con escribir la palabra reservada define y seguido dar un nombre o identificador para la función, a continuación se escriben sus parametros y las instrucciones correspondientes.\nSintácticamente: (define nombre_funcion (num1 num2)\nInstrucciones\n)",
                "3": "\t\t\tC\nFUNCIONES:\nEn C el definir funciones es algo sencillo pero especifico, se debe tener en cuenta el tipo de dato que la función retornará y el tipo de dato de los parametros de entrada.\nSintácticamente:\n tipo_dato_salida nombre_funcion (tipo_dato_entrada entrada1, tipo_dato_entrada entrada2){\n\tInstrucciones\n}"
            },
            "5" : 
            {
                "1": "En este ejemplo se usa:\n\tFunciones\n\tRecursividad",
                "2": "\t\t\tRACKET\nFUNCIONES:\nEn Racket basta con escribir la palabra reservada define y seguido dar un nombre o identificador para la función, a continuación se escriben sus parametros y las instrucciones correspondientes.\nSintácticamente: (define nombre_funcion (num1 num2)\nInstrucciones\n)",
                "3": "\t\t\tC\nFUNCIONES:\nEn C el definir funciones es algo sencillo pero especifico, se debe tener en cuenta el tipo de dato que la función retornará y el tipo de dato de los parametros de entrada.\nSintácticamente:\n tipo_dato_salida nombre_funcion (tipo_dato_entrada entrada1, tipo_dato_entrada entrada2){\n\tInstrucciones\n}"
            },
            "6" : 
            {
                "1": "En este ejemplo se usa:\n\tFunciones\n\tRecursividad",
                "2": "\t\t\tRACKET\nFUNCIONES:\nEn Racket basta con escribir la palabra reservada define y seguido dar un nombre o identificador para la función, a continuación se escriben sus parametros y las instrucciones correspondientes.\nSintácticamente: (define nombre_funcion (num1 num2)\nInstrucciones\n)",
                "3": "\t\t\tC\nFUNCIONES:\nEn C el definir funciones es algo sencillo pero especifico, se debe tener en cuenta el tipo de dato que la función retornará y el tipo de dato de los parametros de entrada.\nSintácticamente:\n tipo_dato_salida nombre_funcion (tipo_dato_entrada entrada1, tipo_dato_entrada entrada2){\n\tInstrucciones\n}"
            }
        },

        "composicion":
        {
            "1" : 
            {
                "1": "En este ejemplo se usa:\n\tComposición de Funciones",
                "2": "\t\t\tRACKET\nCOMPOSICIÓN DE FUNCIONES\nEn Racket es posible anidar funciones, es decir, tener una función en la cual se tenga el llamado a otra función u otras funciones. Esto se hace con el propósito de unir funciones para lograr un solo objetivo.",
                "3": "\t\t\tC\nCOMPOSICIÓN DE FUNCIONES\nEn C existen llamados a funciones dentro de otras, esto se llama composición o anidación de funciones. Cada función retorna un valor que es usado en la función donde se realiza el llamado, esto para lograr un objetivo específico."
            },
            "2" : 
            {
                "1": "En este ejemplo se usa:\n\tComposición de Funciones",
                "2": "\t\t\tRACKET\nCOMPOSICIÓN DE FUNCIONES\nEn Racket es posible anidar funciones, es decir, tener una función en la cual se tenga el llamado a otra función u otras funciones. Esto se hace con el propósito de unir funciones para lograr un solo objetivo.",
                "3": "\t\t\tC\nCOMPOSICIÓN DE FUNCIONES\nEn C existen llamados a funciones dentro de otras, esto se llama composición o anidación de funciones. Cada función retorna un valor que es usado en la función donde se realiza el llamado, esto para lograr un objetivo específico."
            },
            "3" : 
            {
                "1": "En este ejemplo se usa:\n\tComposición de Funciones",
                "2": "\t\t\tRACKET\nCOMPOSICIÓN DE FUNCIONES\nEn Racket es posible anidar funciones, es decir, tener una función en la cual se tenga el llamado a otra función u otras funciones. Esto se hace con el propósito de unir funciones para lograr un solo objetivo.",
                "3": "\t\t\tC\nCOMPOSICIÓN DE FUNCIONES\nEn C existen llamados a funciones dentro de otras, esto se llama composición o anidación de funciones. Cada función retorna un valor que es usado en la función donde se realiza el llamado, esto para lograr un objetivo específico."
            },
            "4" : 
            {
                "1": "En este ejemplo se usa:\n\tComposición de Funciones",
                "2": "\t\t\tRACKET\nCOMPOSICIÓN DE FUNCIONES\nEn Racket es posible anidar funciones, es decir, tener una función en la cual se tenga el llamado a otra función u otras funciones. Esto se hace con el propósito de unir funciones para lograr un solo objetivo.",
                "3": "\t\t\tC\nCOMPOSICIÓN DE FUNCIONES\nEn C existen llamados a funciones dentro de otras, esto se llama composición o anidación de funciones. Cada función retorna un valor que es usado en la función donde se realiza el llamado, esto para lograr un objetivo específico."
            },
            "5" : 
            {
                "1": "En este ejemplo se usa:\n\tComposición de Funciones",
                "2": "\t\t\tRACKET\nCOMPOSICIÓN DE FUNCIONES\nEn Racket es posible anidar funciones, es decir, tener una función en la cual se tenga el llamado a otra función u otras funciones. Esto se hace con el propósito de unir funciones para lograr un solo objetivo.",
                "3": "\t\t\tC\nCOMPOSICIÓN DE FUNCIONES\nEn C existen llamados a funciones dentro de otras, esto se llama composición o anidación de funciones. Cada función retorna un valor que es usado en la función donde se realiza el llamado, esto para lograr un objetivo específico."
            },
            "6" : 
            {
                "1": "En este ejemplo se usa:\n\tComposición de Funciones",
                "2": "\t\t\tRACKET\nCOMPOSICIÓN DE FUNCIONES\nEn Racket es posible anidar funciones, es decir, tener una función en la cual se tenga el llamado a otra función u otras funciones. Esto se hace con el propósito de unir funciones para lograr un solo objetivo.",
                "3": "\t\t\tC\nCOMPOSICIÓN DE FUNCIONES\nEn C existen llamados a funciones dentro de otras, esto se llama composición o anidación de funciones. Cada función retorna un valor que es usado en la función donde se realiza el llamado, esto para lograr un objetivo específico."
            }
        },

        "procedimientos":
        {
            "1" : 
            {
                "1": "En este ejemplo se usa:\n\tProcedimientos",
                "2": "\n\nPROCEDIMIENTOS\nLos procedimientos en Racket son definiciones de funciones que cumplen con ciertas instrucciones las cuales no indican un retorno. Se usan normalmente para procesos de ordenamiento, mensajes en pantalla, etc.",
                "3": "\n\nPROCEDIMIENTOS\nEn C los procedimientos se definen como cualquier otra función, la característica especial sobre dichas funciones es que no retornan nada, es decir, retorno vacio (void)."
            },
            "2" : 
            {
                "1": "En este ejemplo se usa:\n\tProcedimientos",
                "2": "\n\nPROCEDIMIENTOS\nLos procedimientos en Racket son definiciones de funciones que cumplen con ciertas instrucciones las cuales no indican un retorno. Se usan normalmente para procesos de ordenamiento, mensajes en pantalla, etc.",
                "3": "\n\nPROCEDIMIENTOS\nEn C los procedimientos se definen como cualquier otra función, la característica especial sobre dichas funciones es que no retornan nada, es decir, retorno vacio (void)."
            },
            "3" : 
            {
                "1": "En este ejemplo se usa:\n\tProcedimientos",
                "2": "\n\nPROCEDIMIENTOS\nLos procedimientos en Racket son definiciones de funciones que cumplen con ciertas instrucciones las cuales no indican un retorno. Se usan normalmente para procesos de ordenamiento, mensajes en pantalla, etc.",
                "3": "\n\nPROCEDIMIENTOS\nEn C los procedimientos se definen como cualquier otra función, la característica especial sobre dichas funciones es que no retornan nada, es decir, retorno vacio (void)."
            },
            "4" : 
            {
                "1": "En este ejemplo se usa:\n\tProcedimientos",
                "2": "\n\nPROCEDIMIENTOS\nLos procedimientos en Racket son definiciones de funciones que cumplen con ciertas instrucciones las cuales no indican un retorno. Se usan normalmente para procesos de ordenamiento, mensajes en pantalla, etc.",
                "3": "\n\nPROCEDIMIENTOS\nEn C los procedimientos se definen como cualquier otra función, la característica especial sobre dichas funciones es que no retornan nada, es decir, retorno vacio (void)."
            },
            "5" : 
            {
                "1": "En este ejemplo se usa:\n\tProcedimientos",
                "2": "\n\nPROCEDIMIENTOS\nLos procedimientos en Racket son definiciones de funciones que cumplen con ciertas instrucciones las cuales no indican un retorno. Se usan normalmente para procesos de ordenamiento, mensajes en pantalla, etc.",
                "3": "\n\nPROCEDIMIENTOS\nEn C los procedimientos se definen como cualquier otra función, la característica especial sobre dichas funciones es que no retornan nada, es decir, retorno vacio (void)."
            },
            "6" : 
            {
                "1": "En este ejemplo se usa:\n\tProcedimientos",
                "2": "\n\nPROCEDIMIENTOS\nLos procedimientos en Racket son definiciones de funciones que cumplen con ciertas instrucciones las cuales no indican un retorno. Se usan normalmente para procesos de ordenamiento, mensajes en pantalla, etc.",
                "3": "\n\nPROCEDIMIENTOS\nEn C los procedimientos se definen como cualquier otra función, la característica especial sobre dichas funciones es que no retornan nada, es decir, retorno vacio (void)."
            }
        }
    }
]