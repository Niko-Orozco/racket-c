[
    {
        "expresiones":
        {
            "1" : 
            {
                "1": "En este ejemplo se usa:\n\tExpresiones\n\tDefinición de Constantes\n\tAsignación\n\tLectura y Escritura por consola\n\nDe Racket a C\n------------------\n(define radio 0)(define pi 3.141592)\n\t\t\t Vs.\nfloat radio, pi = 3.141592;\n------------------\n(set! radio (read))\n\t\t\t Vs.\nscanf(\"%d\", &radio);\n------------------",
                "2": "\t\t\tRACKET\nCOMENTARIOS:\nLos comentarios pueden ser de una sola linea escribiendo: ;Esto es un comentario\nO pueden ser de varias lineas: \n#| Comentario\nVarias\nLineas |#\n\nEXPRESIONES:\nLas expresiones en racket se escriben entre paréntesis en modo preorden, lo que significa que se recorre la raiz, luego el nodo izquierdo y luego el derecho, es decir, si tenemos la suma: 2+3, sintácticamente se escribiría:\n\t (+ 2 3)\n\nOPERADORES:\nEn Racket Los operadores se escriben al igual que las expresiones, en Pre-Orden\nPara la asignación, re-asignación o reemplazar el valor de una variable se usa la palabra reservada set!\n\nIMPRIMIR POR CONSOLA:\nPara imprimir datos por consola en Racket, se usa la palabra reservada printf y entre comillas dobles se escribe el mensaje. Si se desea imprimir una variable se usa el símbolo: ~a\nSe escribe dentro de los símbolos y el nombre de la variable a imprimir se escribe luego de los símbolos.\nSintácticamente: Si tenemos una variable: numero\nSe imprime de este modo:\n\n(printf \"La variable es ~a\" numero)\n\nLEER POR CONSOLA:\nPara leer datos por consola en racket, se usa la palabra reservada del lenguaje: read, escrita entre paréntesis. \nSe usa en el momento en que se llama a una función, y reemplaza el nombre de la variable por (read) un dato que entra por consola.\nSintácticamente:\nSi tenemos una función (define(comparar (numero1 numero2))\n\tBloque de Instrucciones)\n\nEl llamado a la función seria: (comparar (read) (read))",
                "3": "\t\t\tC\nCOMENTARIOS:\nLos comentarios pueden ser de una sola linea escribiendo: //Esto es un comentario\n O de varias lineas: \n/* Comentario\nVarias\nLineas */\n\nEXPRESIONES:\nLas expresiones constan de operadores y operandos, estos pueden ser: \n\tAritméticos\n\tLógicos\n\tRelacionales\nEn el caso de los operadores arítmeticos se escriben en InOrden, es decir en el orden que normalmente se trabaja a nivel matemático.\n\nOPERADORES:\nEn C hay tres tipos de operadores, aritméticos, lógicos y relacionales los cuales se escriben en In-Orden.\nPara la asignación de un dato a una variable se usa el símbolo de igual =\n\nIMPRIMIR POR CONSOLA:\nPara imprimir datos por consola en C se usa la palabra reservada printf, función de la librería stdio.h (También scanf, para leer datos).\nSe escribe entre comillas dobles el mensaje a mostrar. Si se desea mostrar el valor de una variable se escribe dentro de las comillas el símbolo '%' con la letra que identifica al tipo de dato, luego de las comillas y separado por coma ',' se escribe el nombre de la variable a imprimir.\nSintácticamente: Si se tiene un variable de tipo entero: \nint variable=5;\n\nSe imprime del siguiente modo:\nprintf(\"La variable es: %d\", variable);\n\nLEER POR CONSOLA:\nPara leer datos por consola en C hay que tener en cuenta el tipo de dato que se quiere recoger, se usa la palabra reservada scanf junto con los símbolos '%' y '&'. \nSe escribe el tipo de dato al lado del porcentaje, ambos deben estar entre comillas doble.\nEl nombre de la variable donde se almacenará el valor debe aparecer precedida del símbolo ampersand, ambos luego de una coma.\nSintácticamente:\nSi tenemos una variable de tipo entero:\nint variable;\n\nLeemos un valor para dicha variable así: scanf(\"%d\", &variable);  "
            },
            "2" : 
            {
                "1": "En este ejemplo se usa:\n\tExpresiones\n\tDefinición de Constantes\n\tAsignación\n\tLectura y Escritura por consola\n\nDe Racket a C\n------------------\n(define arista 0) (define volumen 0)\n\t\t\t Vs.\nfloat arista, volumen;\n------------------\n(set! arista (read))\n\t\t\t Vs.\nscanf( \"%d\", &arista );\n------------------\n(set! volumen (expt arista 3)\n\t\t\t Vs.\nvolumen = pow( arista, 3 );\n------------------",
                "2": "\t\t\tRACKET\nCOMENTARIOS:\nLos comentarios pueden ser de una sola linea escribiendo: ;Esto es un comentario\nO pueden ser de varias lineas: \n#| Comentario\nVarias\nLineas |#\n\nEXPRESIONES:\nLas expresiones en racket se escriben entre paréntesis en modo preorden, lo que significa que se recorre la raiz, luego el nodo izquierdo y luego el derecho, es decir, si tenemos la suma: 2+3, sintácticamente se escribiría:\n\t (+ 2 3)\n\nOPERADORES:\nEn Racket Los operadores se escriben al igual que las expresiones, en Pre-Orden\nPara la asignación, re-asignación o reemplazar el valor de una variable se usa la palabra reservada set!\n\nIMPRIMIR POR CONSOLA:\nPara imprimir datos por consola en Racket, se usa la palabra reservada printf y entre comillas dobles se escribe el mensaje. Si se desea imprimir una variable se usa el símbolo: ~a\nSe escribe dentro de los símbolos y el nombre de la variable a imprimir se escribe luego de los símbolos.\nSintácticamente: Si tenemos una variable: numero\nSe imprime de este modo:\n\n(printf \"La variable es ~a\" numero)\n\nLEER POR CONSOLA:\nPara leer datos por consola en racket, se usa la palabra reservada del lenguaje: read, escrita entre paréntesis. \nSe usa en el momento en que se llama a una función, y reemplaza el nombre de la variable por (read) un dato que entra por consola.\nSintácticamente:\nSi tenemos una función (define(comparar (numero1 numero2))\n\tBloque de Instrucciones)\n\nEl llamado a la función seria: (comparar (read) (read))",
                "3": "\t\t\tC\nCOMENTARIOS:\nLos comentarios pueden ser de una sola linea escribiendo: //Esto es un comentario\n O de varias lineas: \n/* Comentario\nVarias\nLineas */\n\nEXPRESIONES:\nLas expresiones constan de operadores y operandos, estos pueden ser: \n\tAritméticos\n\tLógicos\n\tRelacionales\nEn el caso de los operadores arítmeticos se escriben en InOrden, es decir en el orden que normalmente se trabaja a nivel matemático.\n\nOPERADORES:\nEn C hay tres tipos de operadores, aritméticos, lógicos y relacionales los cuales se escriben en In-Orden.\nPara la asignación de un dato a una variable se usa el símbolo de igual =\n\nIMPRIMIR POR CONSOLA:\nPara imprimir datos por consola en C se usa la palabra reservada printf, función de la librería stdio.h (También scanf, para leer datos).\nSe escribe entre comillas dobles el mensaje a mostrar. Si se desea mostrar el valor de una variable se escribe dentro de las comillas el símbolo '%' con la letra que identifica al tipo de dato, luego de las comillas y separado por coma ',' se escribe el nombre de la variable a imprimir.\nSintácticamente: Si se tiene un variable de tipo entero: \nint variable=5;\n\nSe imprime del siguiente modo:\nprintf(\"La variable es: %d\", variable);\n\nLEER POR CONSOLA:\nPara leer datos por consola en C hay que tener en cuenta el tipo de dato que se quiere recoger, se usa la palabra reservada scanf junto con los símbolos '%' y '&'. \nSe escribe el tipo de dato al lado del porcentaje, ambos deben estar entre comillas doble.\nEl nombre de la variable donde se almacenará el valor debe aparecer precedida del símbolo ampersand, ambos luego de una coma.\nSintácticamente:\nSi tenemos una variable de tipo entero:\nint variable;\n\nLeemos un valor para dicha variable así: scanf(\"%d\", &variable);  "
            },
            "3" : 
            {
                "1": "En este ejemplo se usa:\n\tExpresiones\n\tDefinición de Constantes\n\tAsignación\n\tLectura y Escritura por consola\n\nDe Racket a C\n------------------\n(define cat1 0) (define cat2 0)(define hipo 0)\n\t\t\t Vs.\nint cat1, cat2;\nfloat hipo;\n------------------\n(set! cat1 (read))\n\t\t\t Vs.\nscanf( \"%d\", &cat1 );\n(set! hipo (sqrt (+ (expt cat1 2)  (expt cat2 2))))\n\t\t\t Vs.\nhipo = sqrt(pow(cat1, 2) + pow(cat2, 2));\n------------------",
                "2": "\t\t\tRACKET\nCOMENTARIOS:\nLos comentarios pueden ser de una sola linea escribiendo: ;Esto es un comentario\nO pueden ser de varias lineas: \n#| Comentario\nVarias\nLineas |#\n\nEXPRESIONES:\nLas expresiones en racket se escriben entre paréntesis en modo preorden, lo que significa que se recorre la raiz, luego el nodo izquierdo y luego el derecho, es decir, si tenemos la suma: 2+3, sintácticamente se escribiría:\n\t (+ 2 3)\n\nOPERADORES:\nEn Racket Los operadores se escriben al igual que las expresiones, en Pre-Orden\nPara la asignación, re-asignación o reemplazar el valor de una variable se usa la palabra reservada set!\n\nIMPRIMIR POR CONSOLA:\nPara imprimir datos por consola en Racket, se usa la palabra reservada printf y entre comillas dobles se escribe el mensaje. Si se desea imprimir una variable se usa el símbolo: ~a\nSe escribe dentro de los símbolos y el nombre de la variable a imprimir se escribe luego de los símbolos.\nSintácticamente: Si tenemos una variable: numero\nSe imprime de este modo:\n\n(printf \"La variable es ~a\" numero)\n\nLEER POR CONSOLA:\nPara leer datos por consola en racket, se usa la palabra reservada del lenguaje: read, escrita entre paréntesis. \nSe usa en el momento en que se llama a una función, y reemplaza el nombre de la variable por (read) un dato que entra por consola.\nSintácticamente:\nSi tenemos una función (define(comparar (numero1 numero2))\n\tBloque de Instrucciones)\n\nEl llamado a la función seria: (comparar (read) (read))",
                "3": "\t\t\tC\nCOMENTARIOS:\nLos comentarios pueden ser de una sola linea escribiendo: //Esto es un comentario\n O de varias lineas: \n/* Comentario\nVarias\nLineas */\n\nEXPRESIONES:\nLas expresiones constan de operadores y operandos, estos pueden ser: \n\tAritméticos\n\tLógicos\n\tRelacionales\nEn el caso de los operadores arítmeticos se escriben en InOrden, es decir en el orden que normalmente se trabaja a nivel matemático.\n\nOPERADORES:\nEn C hay tres tipos de operadores, aritméticos, lógicos y relacionales los cuales se escriben en In-Orden.\nPara la asignación de un dato a una variable se usa el símbolo de igual =\n\nIMPRIMIR POR CONSOLA:\nPara imprimir datos por consola en C se usa la palabra reservada printf, función de la librería stdio.h (También scanf, para leer datos).\nSe escribe entre comillas dobles el mensaje a mostrar. Si se desea mostrar el valor de una variable se escribe dentro de las comillas el símbolo '%' con la letra que identifica al tipo de dato, luego de las comillas y separado por coma ',' se escribe el nombre de la variable a imprimir.\nSintácticamente: Si se tiene un variable de tipo entero: \nint variable=5;\n\nSe imprime del siguiente modo:\nprintf(\"La variable es: %d\", variable);\n\nLEER POR CONSOLA:\nPara leer datos por consola en C hay que tener en cuenta el tipo de dato que se quiere recoger, se usa la palabra reservada scanf junto con los símbolos '%' y '&'. \nSe escribe el tipo de dato al lado del porcentaje, ambos deben estar entre comillas doble.\nEl nombre de la variable donde se almacenará el valor debe aparecer precedida del símbolo ampersand, ambos luego de una coma.\nSintácticamente:\nSi tenemos una variable de tipo entero:\nint variable;\n\nLeemos un valor para dicha variable así: scanf(\"%d\", &variable);  "
            },
            "4" : 
            {
                "1": "En este ejemplo se usa:\n\tExpresiones\n\tDefinición de Constantes\n\tAsignación\n\tLectura y Escritura por consola\n\nDe Racket a C\n------------------\n(define coste_azucar 0.6)\n(define coste_cafe 0.72)\n\t\t\t Vs.\n#define coste_azucar .6\n#define coste_cafe .72\n------------------\n(define cantidad 0)(define kilos_azucar 0)(define kilos_cafe 0)\n\t\t\t Vs.\nscanf( \"%f\", &cantidad );\n------------------\n(set! kilos_azucar (/ (/ cantidad 2) coste_azucar))\n\t\t\t Vs.\nkilos_azucar = cantidad / 2 / coste_azucar;\n------------------",
                "2": "\t\t\tRACKET\nCOMENTARIOS:\nLos comentarios pueden ser de una sola linea escribiendo: ;Esto es un comentario\nO pueden ser de varias lineas: \n#| Comentario\nVarias\nLineas |#\n\nEXPRESIONES:\nLas expresiones en racket se escriben entre paréntesis en modo preorden, lo que significa que se recorre la raiz, luego el nodo izquierdo y luego el derecho, es decir, si tenemos la suma: 2+3, sintácticamente se escribiría:\n\t (+ 2 3)\n\nOPERADORES:\nEn Racket Los operadores se escriben al igual que las expresiones, en Pre-Orden\nPara la asignación, re-asignación o reemplazar el valor de una variable se usa la palabra reservada set!\n\nIMPRIMIR POR CONSOLA:\nPara imprimir datos por consola en Racket, se usa la palabra reservada printf y entre comillas dobles se escribe el mensaje. Si se desea imprimir una variable se usa el símbolo: ~a\nSe escribe dentro de los símbolos y el nombre de la variable a imprimir se escribe luego de los símbolos.\nSintácticamente: Si tenemos una variable: numero\nSe imprime de este modo:\n\n(printf \"La variable es ~a\" numero)\n\nLEER POR CONSOLA:\nPara leer datos por consola en racket, se usa la palabra reservada del lenguaje: read, escrita entre paréntesis. \nSe usa en el momento en que se llama a una función, y reemplaza el nombre de la variable por (read) un dato que entra por consola.\nSintácticamente:\nSi tenemos una función (define(comparar (numero1 numero2))\n\tBloque de Instrucciones)\n\nEl llamado a la función seria: (comparar (read) (read))",
                "3": "\t\t\tC\nCOMENTARIOS:\nLos comentarios pueden ser de una sola linea escribiendo: //Esto es un comentario\n O de varias lineas: \n/* Comentario\nVarias\nLineas */\n\nEXPRESIONES:\nLas expresiones constan de operadores y operandos, estos pueden ser: \n\tAritméticos\n\tLógicos\n\tRelacionales\nEn el caso de los operadores arítmeticos se escriben en InOrden, es decir en el orden que normalmente se trabaja a nivel matemático.\n\nOPERADORES:\nEn C hay tres tipos de operadores, aritméticos, lógicos y relacionales los cuales se escriben en In-Orden.\nPara la asignación de un dato a una variable se usa el símbolo de igual =\n\nIMPRIMIR POR CONSOLA:\nPara imprimir datos por consola en C se usa la palabra reservada printf, función de la librería stdio.h (También scanf, para leer datos).\nSe escribe entre comillas dobles el mensaje a mostrar. Si se desea mostrar el valor de una variable se escribe dentro de las comillas el símbolo '%' con la letra que identifica al tipo de dato, luego de las comillas y separado por coma ',' se escribe el nombre de la variable a imprimir.\nSintácticamente: Si se tiene un variable de tipo entero: \nint variable=5;\n\nSe imprime del siguiente modo:\nprintf(\"La variable es: %d\", variable);\n\nLEER POR CONSOLA:\nPara leer datos por consola en C hay que tener en cuenta el tipo de dato que se quiere recoger, se usa la palabra reservada scanf junto con los símbolos '%' y '&'. \nSe escribe el tipo de dato al lado del porcentaje, ambos deben estar entre comillas doble.\nEl nombre de la variable donde se almacenará el valor debe aparecer precedida del símbolo ampersand, ambos luego de una coma.\nSintácticamente:\nSi tenemos una variable de tipo entero:\nint variable;\n\nLeemos un valor para dicha variable así: scanf(\"%d\", &variable);  "
            },
            "5" : 
            {
                "1": "En este ejemplo se usa:\n\tExpresiones\n\tDefinición de Constantes\n\tAsignación\n\tLectura y Escritura por consola\n\nDe Racket a C\n------------------\n(define pul 0)(define yar 0)(define met 0)(define mil 0)(define pies 0)(define me 0)\n\t\t\t Vs.\nfloat pul, yar, met, mil, pies, me;\n------------------\n(set! pies (read))\n\t\t\t Vs.\nscanf(\"%f\", &pies);\n------------------\n(set! pul (+ (* pies 12) (/ me 0.0254)))\n\t\t\t Vs.\npul = (pies*12) + (me/0.0254);\n------------------",
                "2": "\t\t\tRACKET\nCOMENTARIOS:\nLos comentarios pueden ser de una sola linea escribiendo: ;Esto es un comentario\nO pueden ser de varias lineas: \n#| Comentario\nVarias\nLineas |#\n\nEXPRESIONES:\nLas expresiones en racket se escriben entre paréntesis en modo preorden, lo que significa que se recorre la raiz, luego el nodo izquierdo y luego el derecho, es decir, si tenemos la suma: 2+3, sintácticamente se escribiría:\n\t (+ 2 3)\n\nOPERADORES:\nEn Racket Los operadores se escriben al igual que las expresiones, en Pre-Orden\nPara la asignación, re-asignación o reemplazar el valor de una variable se usa la palabra reservada set!\n\nIMPRIMIR POR CONSOLA:\nPara imprimir datos por consola en Racket, se usa la palabra reservada printf y entre comillas dobles se escribe el mensaje. Si se desea imprimir una variable se usa el símbolo: ~a\nSe escribe dentro de los símbolos y el nombre de la variable a imprimir se escribe luego de los símbolos.\nSintácticamente: Si tenemos una variable: numero\nSe imprime de este modo:\n\n(printf \"La variable es ~a\" numero)\n\nLEER POR CONSOLA:\nPara leer datos por consola en racket, se usa la palabra reservada del lenguaje: read, escrita entre paréntesis. \nSe usa en el momento en que se llama a una función, y reemplaza el nombre de la variable por (read) un dato que entra por consola.\nSintácticamente:\nSi tenemos una función (define(comparar (numero1 numero2))\n\tBloque de Instrucciones)\n\nEl llamado a la función seria: (comparar (read) (read))",
                "3": "\t\t\tC\nCOMENTARIOS:\nLos comentarios pueden ser de una sola linea escribiendo: //Esto es un comentario\n O de varias lineas: \n/* Comentario\nVarias\nLineas */\n\nEXPRESIONES:\nLas expresiones constan de operadores y operandos, estos pueden ser: \n\tAritméticos\n\tLógicos\n\tRelacionales\nEn el caso de los operadores arítmeticos se escriben en InOrden, es decir en el orden que normalmente se trabaja a nivel matemático.\n\nOPERADORES:\nEn C hay tres tipos de operadores, aritméticos, lógicos y relacionales los cuales se escriben en In-Orden.\nPara la asignación de un dato a una variable se usa el símbolo de igual =\n\nIMPRIMIR POR CONSOLA:\nPara imprimir datos por consola en C se usa la palabra reservada printf, función de la librería stdio.h (También scanf, para leer datos).\nSe escribe entre comillas dobles el mensaje a mostrar. Si se desea mostrar el valor de una variable se escribe dentro de las comillas el símbolo '%' con la letra que identifica al tipo de dato, luego de las comillas y separado por coma ',' se escribe el nombre de la variable a imprimir.\nSintácticamente: Si se tiene un variable de tipo entero: \nint variable=5;\n\nSe imprime del siguiente modo:\nprintf(\"La variable es: %d\", variable);\n\nLEER POR CONSOLA:\nPara leer datos por consola en C hay que tener en cuenta el tipo de dato que se quiere recoger, se usa la palabra reservada scanf junto con los símbolos '%' y '&'. \nSe escribe el tipo de dato al lado del porcentaje, ambos deben estar entre comillas doble.\nEl nombre de la variable donde se almacenará el valor debe aparecer precedida del símbolo ampersand, ambos luego de una coma.\nSintácticamente:\nSi tenemos una variable de tipo entero:\nint variable;\n\nLeemos un valor para dicha variable así: scanf(\"%d\", &variable);  "
            },
            "6" : 
            {
                "1": "En este ejemplo se usa:\n\tExpresiones\n\tDefinición de Constantes\n\tAsignación\n\tLectura y Escritura por consola\n\nDe Racket a C\n------------------\n(define m_c 0)(define li 0)(define y_c 0)(define p_c 0)(define r_m 0)(define r_p 0)(define c_m 0)(define c_p 0)\n\t\t\t Vs.\nfloat m_c, li, y_c, p_c, r_m, r_p, c_m, c_p;\n------------------\n(set! li (read))\n\t\t\t Vs.\nscanf(\"%f\", &li);\n------------------\n(set! m_c ( li 1000))\n\t\t\t Vs.\nm_c = li/1000;\n------------------",
                "2": "\t\t\tRACKET\nCOMENTARIOS:\nLos comentarios pueden ser de una sola linea escribiendo: ;Esto es un comentario\nO pueden ser de varias lineas: \n#| Comentario\nVarias\nLineas |#\n\nEXPRESIONES:\nLas expresiones en racket se escriben entre paréntesis en modo preorden, lo que significa que se recorre la raiz, luego el nodo izquierdo y luego el derecho, es decir, si tenemos la suma: 2+3, sintácticamente se escribiría:\n\t (+ 2 3)\n\nOPERADORES:\nEn Racket Los operadores se escriben al igual que las expresiones, en Pre-Orden\nPara la asignación, re-asignación o reemplazar el valor de una variable se usa la palabra reservada set!\n\nIMPRIMIR POR CONSOLA:\nPara imprimir datos por consola en Racket, se usa la palabra reservada printf y entre comillas dobles se escribe el mensaje. Si se desea imprimir una variable se usa el símbolo: ~a\nSe escribe dentro de los símbolos y el nombre de la variable a imprimir se escribe luego de los símbolos.\nSintácticamente: Si tenemos una variable: numero\nSe imprime de este modo:\n\n(printf \"La variable es ~a\" numero)\n\nLEER POR CONSOLA:\nPara leer datos por consola en racket, se usa la palabra reservada del lenguaje: read, escrita entre paréntesis. \nSe usa en el momento en que se llama a una función, y reemplaza el nombre de la variable por (read) un dato que entra por consola.\nSintácticamente:\nSi tenemos una función (define(comparar (numero1 numero2))\n\tBloque de Instrucciones)\n\nEl llamado a la función seria: (comparar (read) (read))",
                "3": "\t\t\tC\nCOMENTARIOS:\nLos comentarios pueden ser de una sola linea escribiendo: //Esto es un comentario\n O de varias lineas: \n/* Comentario\nVarias\nLineas */\n\nEXPRESIONES:\nLas expresiones constan de operadores y operandos, estos pueden ser: \n\tAritméticos\n\tLógicos\n\tRelacionales\nEn el caso de los operadores arítmeticos se escriben en InOrden, es decir en el orden que normalmente se trabaja a nivel matemático.\n\nOPERADORES:\nEn C hay tres tipos de operadores, aritméticos, lógicos y relacionales los cuales se escriben en In-Orden.\nPara la asignación de un dato a una variable se usa el símbolo de igual =\n\nIMPRIMIR POR CONSOLA:\nPara imprimir datos por consola en C se usa la palabra reservada printf, función de la librería stdio.h (También scanf, para leer datos).\nSe escribe entre comillas dobles el mensaje a mostrar. Si se desea mostrar el valor de una variable se escribe dentro de las comillas el símbolo '%' con la letra que identifica al tipo de dato, luego de las comillas y separado por coma ',' se escribe el nombre de la variable a imprimir.\nSintácticamente: Si se tiene un variable de tipo entero: \nint variable=5;\n\nSe imprime del siguiente modo:\nprintf(\"La variable es: %d\", variable);\n\nLEER POR CONSOLA:\nPara leer datos por consola en C hay que tener en cuenta el tipo de dato que se quiere recoger, se usa la palabra reservada scanf junto con los símbolos '%' y '&'. \nSe escribe el tipo de dato al lado del porcentaje, ambos deben estar entre comillas doble.\nEl nombre de la variable donde se almacenará el valor debe aparecer precedida del símbolo ampersand, ambos luego de una coma.\nSintácticamente:\nSi tenemos una variable de tipo entero:\nint variable;\n\nLeemos un valor para dicha variable así: scanf(\"%d\", &variable);  "
            }
        },

        "secuencia":
        {
            "1" : 
            {
                "1": "En este ejemplo se usa:\n\tExpresiones\n\tDefinición de Variables\n\tUso de Operadores\n\nDe Racket a C\n------------------\n(define variable1 0)(define  variable2 0)\n\t\t\t Vs.\nint variable1, variable2;\n------------------\n(set! variable1 5)\n\t\t\t Vs.\nvariable1=5;\n------------------\n(define caracter \"h\")\n\t\t\t Vs.\nchar caracter='h';\n------------------\n(define suma (+ variable1 variable2))\n\t\t\t Vs.\nint suma = variable1+variable2;\n------------------",
                "2": "\t\t\tRACKET\nEXPRESIONES:\nLas expresiones en racket se escriben entre paréntesis en modo preorden, lo que significa que se recorre la raiz, luego el nodo izquierdo y luego el derecho, es decir, si tenemos la suma: 2+3, sintácticamente se escribiría:\n\t (+ 2 3)\n\nOPERADORES:\nEn Racket Los operadores se escriben al igual que las expresiones, en Pre-Orden\nPara la asignación, re-asignación o reemplazar el valor de una variable se usa la palabra reservada set!",
                "3": "\t\t\tC\nEXPRESIONES:\nLas expresiones constan de operadores y operandos, estos pueden ser: \n\tAritméticos\n\tLógicos\n\tRelacionales\nEn el caso de los operadores arítmeticos se escriben en InOrden, es decir en el orden que normalmente se trabaja a nivel matemático.\n\nOPERADORES:\nEn C hay tres tipos de operadores, aritméticos, lógicos y relacionales los cuales se escriben en In-Orden.\nPara la asignación de un dato a una variable se usa el símbolo de igual ="
            },
            "2" : 
            {
                "1": "En este ejemplo se usa:\n\tExpresiones\n\tDefinición de Variables\n\tUso de Operadores\n\tImpresión por Consola\n\nDe Racket a C\n------------------\n(define  telefono 0)\n\t\t\t Vs.\nlong telefono=0;\n------------------\n(set! telefono (read))\n\t\t\t Vs.\nscanf(\"%ld\", &telefono);\n------------------",
                "2": "\t\t\tRACKET\nEXPRESIONES:\nLas expresiones en racket se escriben entre paréntesis en modo preorden, lo que significa que se recorre la raiz, luego el nodo izquierdo y luego el derecho, es decir, si tenemos la suma: 2+3, sintácticamente se escribiría:\n\t (+ 2 3)\n\nOPERADORES:\nEn Racket Los operadores se escriben al igual que las expresiones, en Pre-Orden\nPara la asignación, re-asignación o reemplazar el valor de una variable se usa la palabra reservada set!\n\nIMPRIMIR POR CONSOLA:\nPara imprimir datos por consola en Racket, se usa la palabra reservada printf y entre comillas dobles se escribe el mensaje. Si se desea imprimir una variable se usa el símbolo: ~a\nSe escribe dentro de los símbolos y el nombre de la variable a imprimir se escribe luego de los símbolos.\nSintácticamente: Si tenemos una variable: numero\nSe imprime de este modo:\n\n(printf \"La variable es ~a\" numero)",
                "3": "\t\t\tC\nEXPRESIONES:\nLas expresiones constan de operadores y operandos, estos pueden ser: \n\tAritméticos\n\tLógicos\n\tRelacionales\nEn el caso de los operadores arítmeticos se escriben en InOrden, es decir en el orden que normalmente se trabaja a nivel matemático.\n\nOPERADORES:\nEn C hay tres tipos de operadores, aritméticos, lógicos y relacionales los cuales se escriben en In-Orden.\nPara la asignación de un dato a una variable se usa el símbolo de igual =\n\nIMPRIMIR POR CONSOLA:\nPara imprimir datos por consola en C se usa la palabra reservada printf, función de la librería stdio.h (También scanf, para leer datos).\nSe escribe entre comillas dobles el mensaje a mostrar. Si se desea mostrar el valor de una variable se escribe dentro de las comillas el símbolo '%' con la letra que identifica al tipo de dato, luego de las comillas y separado por coma ',' se escribe el nombre de la variable a imprimir.\nSintácticamente: Si se tiene un variable de tipo entero: \nint variable=5;\n\nSe imprime del siguiente modo:\nprintf(\"La variable es: %d\", variable);"
            },
            "3" : 
            {
                "1": "En este ejemplo se usa:\n\tExpresiones\n\tDefinición de Variables\n\tUso de Operadores\n\tImpresión por Consola\n\tLectura por consola\n\nDe Racket a C\n------------------\n(define numero 0)\n\t\t\t Vs.\nint numero;\n------------------\n(set! numero (read))\n\t\t\t Vs.\nscanf(\"%d\", &numero);\n------------------",
                "2": "\t\t\tRACKET\nEXPRESIONES:\nLas expresiones en racket se escriben entre paréntesis en modo preorden, lo que significa que se recorre la raiz, luego el nodo izquierdo y luego el derecho, es decir, si tenemos la suma: 2+3, sintácticamente se escribiría:\n\t (+ 2 3)\n\nOPERADORES:\nEn Racket Los operadores se escriben al igual que las expresiones, en Pre-Orden\nPara la asignación, re-asignación o reemplazar el valor de una variable se usa la palabra reservada set!\n\nIMPRIMIR POR CONSOLA:\nPara imprimir datos por consola en Racket, se usa la palabra reservada printf y entre comillas dobles se escribe el mensaje. Si se desea imprimir una variable se usa el símbolo: ~a\nSe escribe dentro de los símbolos y el nombre de la variable a imprimir se escribe luego de los símbolos.\nSintácticamente: Si tenemos una variable: numero\nSe imprime de este modo:\n\n(printf \"La variable es ~a\" numero)\n\nLEER POR CONSOLA:\nPara leer datos por consola en racket, se usa la palabra reservada del lenguaje: read, escrita entre paréntesis. \nSe usa en el momento en que se llama a una función, y reemplaza el nombre de la variable por (read) un dato que entra por consola.\nSintácticamente:\nSi tenemos una función (define(comparar (numero1 numero2))\n\tBloque de Instrucciones)\n\nEl llamado a la función seria: (comparar (read) (read))",
                "3": "\t\t\tC\nEXPRESIONES:\nLas expresiones constan de operadores y operandos, estos pueden ser: \n\tAritméticos\n\tLógicos\n\tRelacionales\nEn el caso de los operadores arítmeticos se escriben en InOrden, es decir en el orden que normalmente se trabaja a nivel matemático.\n\nOPERADORES:\nEn C hay tres tipos de operadores, aritméticos, lógicos y relacionales los cuales se escriben en In-Orden.\nPara la asignación de un dato a una variable se usa el símbolo de igual =\n\nIMPRIMIR POR CONSOLA:\nPara imprimir datos por consola en C se usa la palabra reservada printf, función de la librería stdio.h (También scanf, para leer datos).\nSe escribe entre comillas dobles el mensaje a mostrar. Si se desea mostrar el valor de una variable se escribe dentro de las comillas el símbolo '%' con la letra que identifica al tipo de dato, luego de las comillas y separado por coma ',' se escribe el nombre de la variable a imprimir.\nSintácticamente: Si se tiene un variable de tipo entero: \nint variable=5;\n\nSe imprime del siguiente modo:\nprintf(\"La variable es: %d\", variable);\n\nLEER POR CONSOLA:\nPara leer datos por consola en C hay que tener en cuenta el tipo de dato que se quiere recoger, se usa la palabra reservada scanf junto con los símbolos '%' y '&'. \nSe escribe el tipo de dato al lado del porcentaje, ambos deben estar entre comillas doble.\nEl nombre de la variable donde se almacenará el valor debe aparecer precedida del símbolo ampersand, ambos luego de una coma.\nSintácticamente:\nSi tenemos una variable de tipo entero:\nint variable;\n\nLeemos un valor para dicha variable así: scanf(\"%d\", &variable);  "
            },
            "4" : 
            {
                "1": "En este ejemplo se usa:\n\tExpresiones\n\tDefinición de Variables\n\tUso de Operadores\n\tImpresión por Consola\n\tLectura por consola\n\nDe Racket a C\n------------------\n(define base 0)(define altura 0)(define area 0)\n\t\t\t Vs.\nfloat base=0, altura=0, area=0;\n------------------\n(set! base (read))\n\t\t\t Vs.\nscanf(\"%f\", &base);\n------------------\n(set! area (/ (* base altura) 2))\n\t\t\t Vs.\narea=(base*altura)/2;\n------------------",
                "2": "\t\t\tRACKET\nEXPRESIONES:\nLas expresiones en racket se escriben entre paréntesis en modo preorden, lo que significa que se recorre la raiz, luego el nodo izquierdo y luego el derecho, es decir, si tenemos la suma: 2+3, sintácticamente se escribiría:\n\t (+ 2 3)\n\nOPERADORES:\nEn Racket Los operadores se escriben al igual que las expresiones, en Pre-Orden\nPara la asignación, re-asignación o reemplazar el valor de una variable se usa la palabra reservada set!\n\nIMPRIMIR POR CONSOLA:\nPara imprimir datos por consola en Racket, se usa la palabra reservada printf y entre comillas dobles se escribe el mensaje. Si se desea imprimir una variable se usa el símbolo: ~a\nSe escribe dentro de los símbolos y el nombre de la variable a imprimir se escribe luego de los símbolos.\nSintácticamente: Si tenemos una variable: numero\nSe imprime de este modo:\n\n(printf \"La variable es ~a\" numero)\n\nLEER POR CONSOLA:\nPara leer datos por consola en racket, se usa la palabra reservada del lenguaje: read, escrita entre paréntesis. \nSe usa en el momento en que se llama a una función, y reemplaza el nombre de la variable por (read) un dato que entra por consola.\nSintácticamente:\nSi tenemos una función (define(comparar (numero1 numero2))\n\tBloque de Instrucciones)\n\nEl llamado a la función seria: (comparar (read) (read))",
                "3": "\t\t\tC\nEXPRESIONES:\nLas expresiones constan de operadores y operandos, estos pueden ser: \n\tAritméticos\n\tLógicos\n\tRelacionales\nEn el caso de los operadores arítmeticos se escriben en InOrden, es decir en el orden que normalmente se trabaja a nivel matemático.\n\nOPERADORES:\nEn C hay tres tipos de operadores, aritméticos, lógicos y relacionales los cuales se escriben en In-Orden.\nPara la asignación de un dato a una variable se usa el símbolo de igual =\n\nIMPRIMIR POR CONSOLA:\nPara imprimir datos por consola en C se usa la palabra reservada printf, función de la librería stdio.h (También scanf, para leer datos).\nSe escribe entre comillas dobles el mensaje a mostrar. Si se desea mostrar el valor de una variable se escribe dentro de las comillas el símbolo '%' con la letra que identifica al tipo de dato, luego de las comillas y separado por coma ',' se escribe el nombre de la variable a imprimir.\nSintácticamente: Si se tiene un variable de tipo entero: \nint variable=5;\n\nSe imprime del siguiente modo:\nprintf(\"La variable es: %d\", variable);\n\nLEER POR CONSOLA:\nPara leer datos por consola en C hay que tener en cuenta el tipo de dato que se quiere recoger, se usa la palabra reservada scanf junto con los símbolos '%' y '&'. \nSe escribe el tipo de dato al lado del porcentaje, ambos deben estar entre comillas doble.\nEl nombre de la variable donde se almacenará el valor debe aparecer precedida del símbolo ampersand, ambos luego de una coma.\nSintácticamente:\nSi tenemos una variable de tipo entero:\nint variable;\n\nLeemos un valor para dicha variable así: scanf(\"%d\", &variable);  "
            },
            "5" : 
            {
                "1": "En este ejemplo se usa:\n\tExpresiones\n\tDefinición de Variables\n\tUso de Operadores\n\tImpresión por Consola\n\tLectura por consola\n\nDe Racket a C\n------------------\n(define PI 3.1416)\n\t\t\t Vs.\n#define PI 3.1416\n------------------\n(define r 0)(define h 0)\n(define v 0)\n\t\t\t Vs.\nint r=0,h=0;\nfloat v;\n------------------\n(set! r (read))\n\t\t\t Vs.\nscanf(\"%d\", &r);\n------------------\n(set! v (* PI (* h (* r r))))\n\t\t\t Vs.\nv=PI*r*r*h;\n------------------",
                "2": "\t\t\tRACKET\nEXPRESIONES:\nLas expresiones en racket se escriben entre paréntesis en modo preorden, lo que significa que se recorre la raiz, luego el nodo izquierdo y luego el derecho, es decir, si tenemos la suma: 2+3, sintácticamente se escribiría:\n\t (+ 2 3)\n\nOPERADORES:\nEn Racket Los operadores se escriben al igual que las expresiones, en Pre-Orden\nPara la asignación, re-asignación o reemplazar el valor de una variable se usa la palabra reservada set!\n\nIMPRIMIR POR CONSOLA:\nPara imprimir datos por consola en Racket, se usa la palabra reservada printf y entre comillas dobles se escribe el mensaje. Si se desea imprimir una variable se usa el símbolo: ~a\nSe escribe dentro de los símbolos y el nombre de la variable a imprimir se escribe luego de los símbolos.\nSintácticamente: Si tenemos una variable: numero\nSe imprime de este modo:\n\n(printf \"La variable es ~a\" numero)\n\nLEER POR CONSOLA:\nPara leer datos por consola en racket, se usa la palabra reservada del lenguaje: read, escrita entre paréntesis. \nSe usa en el momento en que se llama a una función, y reemplaza el nombre de la variable por (read) un dato que entra por consola.\nSintácticamente:\nSi tenemos una función (define(comparar (numero1 numero2))\n\tBloque de Instrucciones)\n\nEl llamado a la función seria: (comparar (read) (read))",
                "3": "\t\t\tC\nEXPRESIONES:\nLas expresiones constan de operadores y operandos, estos pueden ser: \n\tAritméticos\n\tLógicos\n\tRelacionales\nEn el caso de los operadores arítmeticos se escriben en InOrden, es decir en el orden que normalmente se trabaja a nivel matemático.\n\nOPERADORES:\nEn C hay tres tipos de operadores, aritméticos, lógicos y relacionales los cuales se escriben en In-Orden.\nPara la asignación de un dato a una variable se usa el símbolo de igual =\n\nIMPRIMIR POR CONSOLA:\nPara imprimir datos por consola en C se usa la palabra reservada printf, función de la librería stdio.h (También scanf, para leer datos).\nSe escribe entre comillas dobles el mensaje a mostrar. Si se desea mostrar el valor de una variable se escribe dentro de las comillas el símbolo '%' con la letra que identifica al tipo de dato, luego de las comillas y separado por coma ',' se escribe el nombre de la variable a imprimir.\nSintácticamente: Si se tiene un variable de tipo entero: \nint variable=5;\n\nSe imprime del siguiente modo:\nprintf(\"La variable es: %d\", variable);\n\nLEER POR CONSOLA:\nPara leer datos por consola en C hay que tener en cuenta el tipo de dato que se quiere recoger, se usa la palabra reservada scanf junto con los símbolos '%' y '&'. \nSe escribe el tipo de dato al lado del porcentaje, ambos deben estar entre comillas doble.\nEl nombre de la variable donde se almacenará el valor debe aparecer precedida del símbolo ampersand, ambos luego de una coma.\nSintácticamente:\nSi tenemos una variable de tipo entero:\nint variable;\n\nLeemos un valor para dicha variable así: scanf(\"%d\", &variable);  "
            },
            "6" : 
            {
                "1": "En este ejemplo se usa:\n\tExpresiones\n\tDefinición de Variables\n\tUso de Operadores\n\tImpresión por Consola\n\tLectura por consola\n\nDe Racket a C\n------------------\n(define lado1 0)(define lado2 0)\n(define diagonal 0)\n\t\t\t Vs.\nint lado1=0, lado2=0;\nfloat diagonal=0;\n------------------\n(set! lado1 (read))\n\t\t\t Vs.\nscanf(\"%d\", &lado1);\n------------------\n(set! diagonal (sqrt (+ (* lado1 lado1) (* lado2 lado2))))\n\t\t\t Vs.\ndiagonal=sqrt(lado1*lado1 + lado2*lado2);\n------------------",
                "2": "\t\t\tRACKET\nEXPRESIONES:\nLas expresiones en racket se escriben entre paréntesis en modo preorden, lo que significa que se recorre la raiz, luego el nodo izquierdo y luego el derecho, es decir, si tenemos la suma: 2+3, sintácticamente se escribiría:\n\t (+ 2 3)\n\nOPERADORES:\nEn Racket Los operadores se escriben al igual que las expresiones, en Pre-Orden\nPara la asignación, re-asignación o reemplazar el valor de una variable se usa la palabra reservada set!\n\nIMPRIMIR POR CONSOLA:\nPara imprimir datos por consola en Racket, se usa la palabra reservada printf y entre comillas dobles se escribe el mensaje. Si se desea imprimir una variable se usa el símbolo: ~a\nSe escribe dentro de los símbolos y el nombre de la variable a imprimir se escribe luego de los símbolos.\nSintácticamente: Si tenemos una variable: numero\nSe imprime de este modo:\n\n(printf \"La variable es ~a\" numero)\n\nLEER POR CONSOLA:\nPara leer datos por consola en racket, se usa la palabra reservada del lenguaje: read, escrita entre paréntesis. \nSe usa en el momento en que se llama a una función, y reemplaza el nombre de la variable por (read) un dato que entra por consola.\nSintácticamente:\nSi tenemos una función (define(comparar (numero1 numero2))\n\tBloque de Instrucciones)\n\nEl llamado a la función seria: (comparar (read) (read))",
                "3": "\t\t\tC\nEXPRESIONES:\nLas expresiones constan de operadores y operandos, estos pueden ser: \n\tAritméticos\n\tLógicos\n\tRelacionales\nEn el caso de los operadores arítmeticos se escriben en InOrden, es decir en el orden que normalmente se trabaja a nivel matemático.\n\nOPERADORES:\nEn C hay tres tipos de operadores, aritméticos, lógicos y relacionales los cuales se escriben en In-Orden.\nPara la asignación de un dato a una variable se usa el símbolo de igual =\n\nIMPRIMIR POR CONSOLA:\nPara imprimir datos por consola en C se usa la palabra reservada printf, función de la librería stdio.h (También scanf, para leer datos).\nSe escribe entre comillas dobles el mensaje a mostrar. Si se desea mostrar el valor de una variable se escribe dentro de las comillas el símbolo '%' con la letra que identifica al tipo de dato, luego de las comillas y separado por coma ',' se escribe el nombre de la variable a imprimir.\nSintácticamente: Si se tiene un variable de tipo entero: \nint variable=5;\n\nSe imprime del siguiente modo:\nprintf(\"La variable es: %d\", variable);\n\nLEER POR CONSOLA:\nPara leer datos por consola en C hay que tener en cuenta el tipo de dato que se quiere recoger, se usa la palabra reservada scanf junto con los símbolos '%' y '&'. \nSe escribe el tipo de dato al lado del porcentaje, ambos deben estar entre comillas doble.\nEl nombre de la variable donde se almacenará el valor debe aparecer precedida del símbolo ampersand, ambos luego de una coma.\nSintácticamente:\nSi tenemos una variable de tipo entero:\nint variable;\n\nLeemos un valor para dicha variable así: scanf(\"%d\", &variable);  "
            }
        },

        "condicionales":
        {
            "1" : 
            {
                "1": "En este ejemplo se usa:\n\tCondicional Simple: IF\n\nDe Racket a C\n------------------\n(if (< num 0)\n\t(printf \"Numero negativo: ~a\" num)\n\t(printf \"Numero positivo: ~a\" num)\n)\n\t\t\t Vs.\nif (num < 0){\n\tprintf (\"Numero negativo: %d\", num);\n\tprintf (\"Numero positivo: %d\", num);\n}\n------------------\n(main (read))\n\t\t\t Vs.\nscanf(\"%d\", &num);\n------------------",
                "2": "\t\t\tRACKET\nSELECCIÓN SIMPLE:\nLa sentencia if analiza una condición escrita entre paréntesis, en caso de ser verdadera ejecuta la primera sentencia, sino, ejecuta la segunda.\nSintácticamente:\n(if(condicion)\n\tcondicion_true\n\tcondicion_false\n)",
                "3": "\t\t\tC\nSELECCIÓN SIMPLE:\nLa sentencia if evalua una condición escrita entre paréntesis y ejecuta la siguiente instrucción o conjunto de instrucciones.\nSintácticamente:\nif(condicion){\n\tBloque instrucciones\n}"
            },
            "2" : 
            {
                "1": "En este ejemplo se usa:\n\tCondicional Simple: IF\n\nDe Racket a C\n------------------\n(if (and (> num1 num2) (> num1 num3))\n\t(printf \"El número mayor es: ~a\" num1)\n)\n\t\t\t Vs.\nif((num1 > num2) && (num1 > num3)){\n\tprintf (\"El número mayor es: %d\", num1);\n}\n------------------\n(Mayor? (read) (read) (read))\n\t\t\t Vs.\nscanf(\"%d\", &num1);\nscanf(\"%d\", &num2);\nscanf(\"%d\", &num3);\n------------------",
                "2": "\t\t\tRACKET\nSELECCIÓN SIMPLE:\nLa sentencia if analiza una condición escrita entre paréntesis, en caso de ser verdadera ejecuta la primera sentencia, sino, ejecuta la segunda.\nSintácticamente:\n(if(condicion)\n\tcondicion_true\n\tcondicion_false\n)",
                "3": "\t\t\tC\nSELECCIÓN SIMPLE:\nLa sentencia if evalua una condición escrita entre paréntesis y ejecuta la siguiente instrucción o conjunto de instrucciones.\nSintácticamente:\nif(condicion){\n\tBloque instrucciones\n}"
            },
            "3" : 
            {
                "1": "En este ejemplo se usa:\n\tCondicional Simple: IF\n\nDe Racket a C\n------------------\n(if (>= nota 3.5)\n\t(printf \"Aprobó la materia\")\n\t(if (and (>= nota 3) (< nota 3.4))\n\t\t(printf \"Presenta prueba de validación\")\n\t\t(if (and (>= nota 0) (< nota 3))\n\t\t\t(printf \"Reprobó la materia\")\n\t\t\t(printf \"Ingrese una nota valida\")\n\t\t)\n\t)\n)\n\t\t\t Vs.\nif(nota >= 3.5){\n\tprintf (\"Aprobó la materia\");\n\t}else{\n\t\tif ((nota >= 3) && (nota < 3.4)){\n\t\tprintf (\"Presenta prueba de validación\");\n\t\t}else{\n\t\tif ((nota >= 0) && (nota < 3)){\n\t\t\tprintf (\"Reprobó la materia\");\n\t\t\t}else{\n\t\t\tprintf (\"Ingrese una nota valida\");\n\t\t}\n\t}\n}\n------------------\n(aprobo? (read))\n\t\t\t Vs.\nscanf(\"%s\", &nota);\n------------------",
                "2": "\t\t\tRACKET\nSELECCIÓN SIMPLE:\nLa sentencia if analiza una condición escrita entre paréntesis, en caso de ser verdadera ejecuta la primera sentencia, sino, ejecuta la segunda.\nSintácticamente:\n(if(condicion)\n\tcondicion_true\n\tcondicion_false\n)",
                "3": "\t\t\tC\nSELECCIÓN SIMPLE:\nLa sentencia if evalua una condición escrita entre paréntesis y ejecuta la siguiente instrucción o conjunto de instrucciones.\nSintácticamente:\nif(condicion){\n\tBloque instrucciones\n}"
            },
            "4" : 
            {
                "1": "En este ejemplo se usa:\n\tCondicional Múltiple: COND/SWITCH-CASE\n\nDe Racket a C\n------------------\n(define opc (read))\n\t\t\t Vs.\nscanf(\"%d\", &opcion);\n------------------\n(cond\n\t[(= opc 1)(printf \"Ingrese el lado: \")\n\t(printf \"Perimetro: ~a\" (* 3 (read)))]\n\n\t[else (printf \"Ingrese una opción valida\")]\n\t\t\t Vs.\nswitch (opcion)\n{\n\tcase 1:\n\t\tprintf(\"Introduzca lado del triángulo:\");\n\t\tscanf(\"%d\",&lado);\n\t\tprintf(\"El perímetro es: %d\",3*lado);\n\tbreak;\n\n\tdefault:\n\t\tprintf(\"Opción no válida.\");\n\tbreak;\n------------------",
                "2": "\t\t\tRACKET\nSELECCIÓN MÚLTIPLE:\nPara las selecciones múltiples se usa la palabra reservada COND y se analizan distintas opciones escritas entre paréntesis, dentro de cada posible opción se hace una comparación y si esta es verdadera, se ejecuta la instrucción continua. Si ninguna condición se cumple se puede colocar una opción por defecto con la palabra de reservada: else.\n\nSintácticamnete: ( COND\n\t[(= opcion 1)(Instrucciones para opción 1)] \n\t[(= opcion 2)(Instrucciones para opción 2)]\n\t[else (Instrucciones por defecto)] )",
                "3": "\t\t\tC\nSELECCIÓN MÚLTIPLE:\nPara seleccionar de manera múltiple se usa el switch-Case, dos palabras reservadas que de acuerdo al valor de una variable analizan n posibilidades distintas, también existe la posibilidad de asignar instrucciones cuando la variable no toma ningun valor dentro de los posibles casos.\nCada uno de los casos debe tener la palabra reservada: break para garantizar la salida de la estructura.\nSintácticamente:\nswitch(variable){\n\tCase 1: Opcion1\n\tCase 2: Opcion2\n\t.\n\tCase N: OpcionN\n\t.\n\tdefault: Opcion_por_defecto\n}"
            },
            "5" : 
            {
                "1": "En este ejemplo se usa:\n\tCondicional Múltiple: COND/SWITCH-CASE\n\nDe Racket a C\n------------------\n(define opc (read))\n\t\t\t Vs.\nscanf(\"%d\", &opcion);\n------------------\n(cond\n\t[(= opc 1) (printf \"Ingrese un numero entre 1 y 7: \")(define (dia (read)))\n\t\t(cond\n\t\t[(= opc 1)(printf \"Lunes\")]\n\n\t[else (printf \"Ingrese una opción valida\")]\n\t\t\t Vs.\nswitch (opcion){\n\tcase 1: printf(\"Ingrese un numero entre 1 y 7: \");\n\tswitch (dia){\n\t\tcase 1: printf(\"Lunes\");\n\tbreak;\n\n\tdefault: printf(\"Ingrese una opción valida\");\n\tbreak;\n------------------",
                "2": "\t\t\tRACKET\nSELECCIÓN MÚLTIPLE:\nPara las selecciones múltiples se usa la palabra reservada COND y se analizan distintas opciones escritas entre paréntesis, dentro de cada posible opción se hace una comparación y si esta es verdadera, se ejecuta la instrucción continua. Si ninguna condición se cumple se puede colocar una opción por defecto con la palabra de reservada: else.\n\nSintácticamnete: ( COND\n\t[(= opcion 1)(Instrucciones para opción 1)] \n\t[(= opcion 2)(Instrucciones para opción 2)]\n\t[else (Instrucciones por defecto)] )",
                "3": "\t\t\tC\nSELECCIÓN MÚLTIPLE:\nPara seleccionar de manera múltiple se usa el switch-Case, dos palabras reservadas que de acuerdo al valor de una variable analizan n posibilidades distintas, también existe la posibilidad de asignar instrucciones cuando la variable no toma ningun valor dentro de los posibles casos.\nCada uno de los casos debe tener la palabra reservada: break para garantizar la salida de la estructura.\nSintácticamente:\nswitch(variable){\n\tCase 1: Opcion1\n\tCase 2: Opcion2\n\t.\n\tCase N: OpcionN\n\t.\n\tdefault: Opcion_por_defecto\n}"
            },
            "6" : 
            {
                "1": "En este ejemplo se usa:\n\tCondicional Múltiple: COND/SWITCH-CASE\n\tCondicional Simple: IF\n\nDe Racket a C\n------------------\n(define opc (read))\n\t\t\t Vs.\nscanf(\"%d\", &opcion);\n------------------\n(cond\n\t[(= opc 1)\n\t\t(if (> anios 15)\n\t\t\t(printf \"Salario anual de: ~a\" (+ (* 40000 1.2) 40000))\n\t\t\t(if (and (< anios 15) (> anios 10))\n\t\t\t(printf \"Salario anual de: ~a\" (+ (* 40000 0.8) 40000))\n\n\t[else (printf \"Ingrese una opción valida\")]\n\t\t\t Vs.\nswitch (opcion){\n\tcase 1:\n\t\tif (anios > 15){\n\t\tprintf (\"Salario anual de: %d\", ((40000 * 1.2) + 40000));\n\t}else{\n\t\tif ((anios < 15) && (anios > 10)){\n\t\t\tprintf (\"Salario anual de: %d\", ((40000 * 0.8) + 40000));\n\n\tdefault: printf(\"Opción no válida.\");\n\tbreak;\n------------------",
                "2": "\t\t\tRACKET\nSELECCIÓN MÚLTIPLE:\nPara las selecciones múltiples se usa la palabra reservada COND y se analizan distintas opciones escritas entre paréntesis, dentro de cada posible opción se hace una comparación y si esta es verdadera, se ejecuta la instrucción continua. Si ninguna condición se cumple se puede colocar una opción por defecto con la palabra de reservada: else.\n\nSintácticamnete: ( COND\n\t[(= opcion 1)(Instrucciones para opción 1)] \n\t[(= opcion 2)(Instrucciones para opción 2)]\n\t[else (Instrucciones por defecto)] )\n\nSELECCIÓN SIMPLE:\nLa sentencia if analiza una condición escrita entre paréntesis, en caso de ser verdadera ejecuta la primera sentencia, sino, ejecuta la segunda.\nSintácticamente:\n(if(condicion)\n\tcondicion_true\n\tcondicion_false\n)",
                "3": "\t\t\tC\nSELECCIÓN MÚLTIPLE:\nPara seleccionar de manera múltiple se usa el switch-Case, dos palabras reservadas que de acuerdo al valor de una variable analizan n posibilidades distintas, también existe la posibilidad de asignar instrucciones cuando la variable no toma ningun valor dentro de los posibles casos.\nCada uno de los casos debe tener la palabra reservada: break para garantizar la salida de la estructura.\nSintácticamente:\nswitch(variable){\n\tCase 1: Opcion1\n\tCase 2: Opcion2\n\t.\n\tCase N: OpcionN\n\t.\n\tdefault: Opcion_por_defecto\n}\n\nSELECCIÓN SIMPLE:\nLa sentencia if evalua una condición escrita entre paréntesis y ejecuta la siguiente instrucción o conjunto de instrucciones.\nSintácticamente:\nif(condicion){\n\tBloque instrucciones\n}"
            }
        },

        "ciclos":
        {
            "1" : 
            {
                "1": "En este ejemplo se usa:\n\tEstructura de iteración: FOR\n\nDe Racket a C\n------------------\n(for ([contador (in-range 1 11 1)])\n\t(printf \"\\n~a\" contador)\n)\n\t\t\t Vs.\nint contador=0;\nfor(contador=1; contador<11 ; contador++ ){\n\tprintf(\"\\n%d\",contador);\n}\n------------------",
                "2": "\t\t\tRACKET\nFOR:\nSe usa una variable para la cual se establece un rango de iteración. Se escribe la palabra reservada in-range y se coloca el inicio, el límite y la manera en que aumenta. Se separan por espacios en blanco.\nSintácticamente: \nfor(i (in-range inicio limite aumento))",
                "3": "\t\t\tC\nFOR:\nSe usa una variable (i) para la cual se establece un inicio, límite y la manera en que aumenta. Se separan por punto y coma ; \nSintácticamente:\nfor(i=inicio; i<limite; i++){\n\tCuerpo de Bucle\n\t}"
            },
            "2" : 
            {
                "1": "En este ejemplo se usa:\n\tEstructura de iteración: FOR\n\nDe Racket a C\n------------------\n(for ([i (in-range 0 5 1)])\n\t(for ([j (in-range 0 5 1)])\n\t\t(printf \" ~a\" j)\n\t)\n\t(printf \"\\n\")\n)\n\t\t\t Vs.\nfor (int i = 0; i<5; i++){\n\tfor (int j=0; j<5; j++){\n\t\tprintf(\"%d\", j);\n\t}\n\tprintf(\"\\n\");\n}\n------------------",
                "2": "\t\t\tRACKET\nFOR:\nSe usa una variable para la cual se establece un rango de iteración. Se escribe la palabra reservada in-range y se coloca el inicio, el límite y la manera en que aumenta. Se separan por espacios en blanco.\nSintácticamente: \nfor(i (in-range inicio limite aumento))",
                "3": "\t\t\tC\nFOR:\nSe usa una variable (i) para la cual se establece un inicio, límite y la manera en que aumenta. Se separan por punto y coma ; \nSintácticamente:\nfor(i=inicio; i<limite; i++){\n\tCuerpo de Bucle\n\t}"
            },
            "3" : 
            {
                "1": "En este ejemplo se usa:\n\tEstructura de iteración: WHILE\n\tCondicional Simple: IF\n\nDe Racket a C\n------------------\n(define c 1)(define par 0)(define impar 0)\n\t\t\t Vs.\nint num, c = 1, par = 0, impar = 0;\n------------------\n(define num (read))\n\t\t\t Vs.\nscanf(\"%d\", &num);\n------------------\n(while (< c num)\n\t(if (= (remainder c 2) 0)\n\t\t(set! par (+ par c))\n\t\t(set! impar (+ impar c))\n\t)\n\t(set! c (+ c 1))\n)\n\t\t\t Vs.\nwhile (c < num){\n\tif(c % 2 == 0){\n\t\tpar += c;\n\t}else{ impar += c; }\n\tc++;\n}\n------------------",
                "2": "\t\t\tRACKET\n\nWHILE:\nLa estructura de iteración while repite un conjunto de instrucciones siempre y cuando una condición se cumpla.\nSintácticamnete, se escribe entre paréntesis se escribe la palabra reservada while y luego la condición a evaluar. La condición como todas las expresiones en racket, se debe escribir en Pre-Orden.\nAsí:\n(while (< i 1)\nInstrucciones\n)\n\nSELECCIÓN SIMPLE:\nLa sentencia if analiza una condición escrita entre paréntesis, en caso de ser verdadera ejecuta la primera sentencia, sino, ejecuta la segunda.\nSintácticamente:\n(if(condicion)\n\tcondicion_true\n\tcondicion_false\n)",
                "3": "\t\t\tC\n\nWHILE:\nLa estructura repetitiva While se usa para repetir un conjunto de instrucciones siempre y cuando una condición se cumpla.\nA nivel de sintaxis se escribe la palabra reservada while y entre paréntesis la condición a evaluar, así:\nwhile(condicion_de_finalizacion){\n\tInstrucciones\n}\n\nSELECCIÓN SIMPLE:\nLa sentencia if evalua una condición escrita entre paréntesis y ejecuta la siguiente instrucción o conjunto de instrucciones.\nSintácticamente:\nif(condicion){\n\tBloque instrucciones\n}"
            },
            "4" : 
            {
                "1": "En este ejemplo se usa:\n\tEstructura de iteración: WHILE\n\nDe Racket a C\n------------------\n(define k 1)(define i (read))\n\t\t\t Vs.\nint k, i;\nscanf(\"%d\",&i);\n------------------\n(while (>= i  1)\n\t(set! k 1)\n\t(while (<= k i)\n\t\t(printf \"~a\" k)\n\t\t(set! k (+ k 1))\n\t)\n\t(set! i (- i 1))\n)\n\t\t\t Vs.\nwhile(i >= 1){\n\tk = 1;\n\twhile(k <= i){\n\t\tprintf(\"%d\t\",k);\n\t\tk++;\n\t}\n\ti--;\n}\n------------------",
                "2": "\t\t\tRACKET\n\nWHILE:\nLa estructura de iteración while repite un conjunto de instrucciones siempre y cuando una condición se cumpla.\nSintácticamnete, se escribe entre paréntesis se escribe la palabra reservada while y luego la condición a evaluar. La condición como todas las expresiones en racket, se debe escribir en Pre-Orden.\nAsí:\n(while (< i 1)\nInstrucciones\n)",
                "3": "\t\t\tC\n\nWHILE:\nLa estructura repetitiva While se usa para repetir un conjunto de instrucciones siempre y cuando una condición se cumpla.\nA nivel de sintaxis se escribe la palabra reservada while y entre paréntesis la condición a evaluar, así:\nwhile(condicion_de_finalizacion){\n\tInstrucciones\n}"
            },
            "5" : 
            {
                "1": "En este ejemplo se usa:\n\tEstructura de iteración: DO (Racket) / DO WHILE (C)\n\nDe Racket a C\n------------------\n(define edad 12)(define d 10)(define total 10)(define i 0)\n\t\t\t Vs.\nint edad = 12, d = 10, total = 10;\n------------------\n(do ((i 1 (+ i 1))) ((< total 1000))\n\t(set! d (* d 2))\n\t(set! total (+ total d))\n\t(set! edad (+ edad 1))\n)\n\t\t\t Vs.\ndo{\n\td = d * 2;\n\ttotal += d;\n\tedad++;\n}while(total < 1000);\n------------------",
                "2": "\t\t\tRACKET\nDO:\nLa estructura repetitiva que ejecuta instrucciones y luego evalua en Racket se define por la palabra reservada do, sintácticamnete se coloca entre paréntesis la palabra do y se usa una variable para la cual se establece un inicio, la manera como incrementa y un límite.\nSintácticamnete:\nSea v la variable a iterar: \n(d (v inicio (+ v incremento)) (< v limite)\n\tInstrucciones\n))",
                "3": "\t\t\tC\nDO WHILE:\nEn C, la estructura repetitiva que ejecuta instrucciones y luego evalua se llama do-while. Se usa las palabras reservadas do y while, y entre corchetes se escribe las instrucciones a repetir, se finaliza con ;\nSintácticamente:\ndo{\n\tInstrucciones\n}while(condicion);"
            },
            "6" : 
            {
                "1": "En este ejemplo se usa:\n\tEstructura de iteración: DO (Racket) / DO WHILE (C)\n\tEstructura de iteración: WHILE\n\nDe Racket a C\n------------------\n(define i = 1)(define m = 0)\n(define fact 0)(define suma 0)\n\t\t\t Vs.\nint n, i = 1, m;\nfloat fact, suma = 0;\n------------------\n(define suma (read))\n\t\t\t Vs.\nscanf(\"%d\",&n);\n------------------\n(do ((i 1 (+ i 1))) ((<= i n))\n\t(set! fact 1)\n\t(set! m = i)\n\t(while (> m 1)\n\t\t(set! fact (* fact m))\n\t\t(set! m (- m 1))\n\t)\n\t(set! suma (+ suma fact))\n\t(printf \"\\t ~a! = ~a \" i fact)\n\t(set! i (+ i 1))\n)\n\t\t\t Vs.\ndo{\n\tfact = 1;\n\tm = i;\n\twhile(m > 1){\n\t\tfact *= m;\n\t\tm--;\n\t}\n\tsuma+=fact;\n\tprintf(\"\\t %d! = %0.f\",i,fact);\n\ti++;\n}while(i <= n);\n------------------",
                "2": "\t\t\tRACKET\nDO:\nLa estructura repetitiva que ejecuta instrucciones y luego evalua en Racket se define por la palabra reservada do, sintácticamnete se coloca entre paréntesis la palabra do y se usa una variable para la cual se establece un inicio, la manera como incrementa y un límite.\nSintácticamnete:\nSea v la variable a iterar: \n(d (v inicio (+ v incremento)) (< v limite)\n\tInstrucciones\n))\n\nWHILE:\nLa estructura de iteración while repite un conjunto de instrucciones siempre y cuando una condición se cumpla.\nSintácticamnete, se escribe entre paréntesis se escribe la palabra reservada while y luego la condición a evaluar. La condición como todas las expresiones en racket, se debe escribir en Pre-Orden.\nAsí:\n(while (< i 1)\nInstrucciones\n)",
                "3": "\t\t\tC\nDO WHILE:\nEn C, la estructura repetitiva que ejecuta instrucciones y luego evalua se llama do-while. Se usa las palabras reservadas do y while, y entre corchetes se escribe las instrucciones a repetir, se finaliza con ;\nSintácticamente:\ndo{\n\tInstrucciones\n}while(condicion);\n\nWHILE:\nLa estructura repetitiva While se usa para repetir un conjunto de instrucciones siempre y cuando una condición se cumpla.\nA nivel de sintaxis se escribe la palabra reservada while y entre paréntesis la condición a evaluar, así:\nwhile(condicion_de_finalizacion){\n\tInstrucciones\n}"
            }
        },

        "cadenas":
        {
            "1" : 
            {
                "1": "En este ejemplo se usa:\n\tCadenas\n\nDe Racket a C\n------------------\n(define cad \"\")\n(define cadMayus \"\")\n\t\t\t Vs.\nchar cadena[20];\nchar cadenaMayus[20];\n------------------\n(set! cad (string-copy (read)))\n\t\t\t Vs.\nscanf(\"%s\", cadena);\n------------------\n(set! cadMayus (string-upcase cad))\n\t\t\t Vs.\nfor(i=0; i<strlen(cadena); i++){\n\tcadenaMayus[i] =toupper(cadena[i]);\n}\n------------------",
                "2": "\t\t\tRACKET\nCADENAS:\nLas cadenas en Racket se definen como cualquier otra variable, se usa la palabra define y un identificador o nombre para dicha variable, seguidamente se inicializa la cadena entre comillas dobles \"\".\nSintácticamnete: \n(define cadena1 \"\")\n(define cadena2 \"Hola Mundo\")\n\nFunciones para cadenas:\n En Racket las funciones para el manejo de cadenas vienen nativas con el lenguaje, es decir, no hay que importar módulos o librerías.",
                "3": "\t\t\tC\nCADENAS:\nLas cadenas en C son un tipo de dato de char, solo que no almacena un solo caracter, sino que almacena varios caracteres en una sola variable, por lo que a nivel de sintaxis una cadena se declara así:\nchar cadena[]\nEs opcional ponerle el tamaño a la cadena, depende si se inicializa en el momento o no.\n*El caso especial para capturar cadenas por consola es que no se usa el ampersand & a la hora de colocar el nombre de la variable.\n\nFunciones para cadenas:\n En C existen librerías que permiten el manejo de funciones (copiar, concatenar, comparar, etc.) estas funciones se usan importando la librería: string.h "
            },
            "2" : 
            {
                "1": "En este ejemplo se usa:\n\tCadenas\n\tEstructura de iteración: FOR\n\nDe Racket a C\n------------------\n(define cad \"\")\n(define cadReverse \"\")\n\t\t\t Vs.\nchar cadena[20];\nchar cadena_invertida[20]={};\n------------------\n(set! cad (read))\n\t\t\t Vs.\ngets(cadena);\n------------------\n(define tam (string-length cad))\n\t\t\t Vs.\ntam=strlen(cadena)-1;\n------------------\n(for ([i (in-range 0 (string-length cad) 1)])\n\t(string-copy! cadReverse tam (string-ref cad i))\n\t(set! tam (- tam 1))\n)\n\t\t\t Vs.\nfor(i=0; i<strlen(cadena); i++){\n\tcadena_invertida[tam]=cadena[i];\n\ttam--;\n}\n------------------",
                "2": "\t\t\tRACKET\nCADENAS:\nLas cadenas en Racket se definen como cualquier otra variable, se usa la palabra define y un identificador o nombre para dicha variable, seguidamente se inicializa la cadena entre comillas dobles \"\".\nSintácticamnete: \n(define cadena1 \"\")\n(define cadena2 \"Hola Mundo\")\n\nFunciones para cadenas:\n En Racket las funciones para el manejo de cadenas vienen nativas con el lenguaje, es decir, no hay que importar módulos o librerías.\n\nFOR:\nSe usa una variable para la cual se establece un rango de iteración. Se escribe la palabra reservada in-range y se coloca el inicio, el límite y la manera en que aumenta. Se separan por espacios en blanco.\nSintácticamente: \nfor(i (in-range inicio limite aumento))",
                "3": "\t\t\tC\nCADENAS:\nLas cadenas en C son un tipo de dato de char, solo que no almacena un solo caracter, sino que almacena varios caracteres en una sola variable, por lo que a nivel de sintaxis una cadena se declara así:\nchar cadena[]\nEs opcional ponerle el tamaño a la cadena, depende si se inicializa en el momento o no.\n*El caso especial para capturar cadenas por consola es que no se usa el ampersand & a la hora de colocar el nombre de la variable.\n\nFunciones para cadenas:\n En C existen librerías que permiten el manejo de funciones (copiar, concatenar, comparar, etc.) estas funciones se usan importando la librería: string.h \n\nFOR:\nSe usa una variable (i) para la cual se establece un inicio, límite y la manera en que aumenta. Se separan por punto y coma ; \nSintácticamente:\nfor(i=inicio; i<limite; i++){\n\tCuerpo de Bucle\n\t}"
            },
            "3" : 
            {
                "1": "En este ejemplo se usa:\n\tCadenas\n\tEstructura de iteración: FOR\n\tCondicional Simple: IF\n\nDe Racket a C\n------------------\n(define mayus 0)(define minus 0)\n(define cad \"\")\n\t\t\t Vs.\nint contador_mayus=0, contador_minus=0, j, i;\nchar cadena[20];\n------------------\n(set! cad (read))\n\t\t\t Vs.\nscanf(\"%s\", cadena);\n------------------\n(for ([i (in-range 0 (string-length cad) 1)])\n\t(for ([j (in-range 65 90 1)])\n\t\t(if (= (char->integer (string-ref cad i)) j)\n\t\t\t(set! mayus (+ mayus 1))\n\t\t)\n\t)\n\t(for ([j (in-range 97 122 1)])\n\t\t(if (= (char->integer (string-ref cad i)) j)\n\t\t\t(set! minus (+ minus 1))\n\t\t)\n\t)\n)\n\t\t\t Vs.\nfor(i=0; i<strlen(cadena); i++){\n\tfor(j=65; j<=90; j++){\n\t\tif(cadena[i]==j)contador_mayus++;\n\t}\n\tfor(j=97; j<=122; j++){\n\t\tif(cadena[i]==j)contador_minus++;\n\t}\n}\n------------------",
                "2": "\t\t\tRACKET\nCADENAS:\nLas cadenas en Racket se definen como cualquier otra variable, se usa la palabra define y un identificador o nombre para dicha variable, seguidamente se inicializa la cadena entre comillas dobles \"\".\nSintácticamnete: \n(define cadena1 \"\")\n(define cadena2 \"Hola Mundo\")\n\nFunciones para cadenas:\n En Racket las funciones para el manejo de cadenas vienen nativas con el lenguaje, es decir, no hay que importar módulos o librerías.\n\nFOR:\nSe usa una variable para la cual se establece un rango de iteración. Se escribe la palabra reservada in-range y se coloca el inicio, el límite y la manera en que aumenta. Se separan por espacios en blanco.\nSintácticamente: \nfor(i (in-range inicio limite aumento))\n\nSELECCIÓN SIMPLE:\nLa sentencia if analiza una condición escrita entre paréntesis, en caso de ser verdadera ejecuta la primera sentencia, sino, ejecuta la segunda.\nSintácticamente:\n(if(condicion)\n\tcondicion_true\n\tcondicion_false\n)",
                "3": "\t\t\tC\nCADENAS:\nLas cadenas en C son un tipo de dato de char, solo que no almacena un solo caracter, sino que almacena varios caracteres en una sola variable, por lo que a nivel de sintaxis una cadena se declara así:\nchar cadena[]\nEs opcional ponerle el tamaño a la cadena, depende si se inicializa en el momento o no.\n*El caso especial para capturar cadenas por consola es que no se usa el ampersand & a la hora de colocar el nombre de la variable.\n\nFunciones para cadenas:\n En C existen librerías que permiten el manejo de funciones (copiar, concatenar, comparar, etc.) estas funciones se usan importando la librería: string.h \n\nFOR:\nSe usa una variable (i) para la cual se establece un inicio, límite y la manera en que aumenta. Se separan por punto y coma ; \nSintácticamente:\nfor(i=inicio; i<limite; i++){\n\tCuerpo de Bucle\n\t}\n\nSELECCIÓN SIMPLE:\nLa sentencia if evalua una condición escrita entre paréntesis y ejecuta la siguiente instrucción o conjunto de instrucciones.\nSintácticamente:\nif(condicion){\n\tBloque instrucciones\n}"
            },
            "4" : 
            {
                "1": "En este ejemplo se usa:\n\tCadenas\n\tEstructura de iteración: FOR\n\tCondicional Simple: IF\n\nDe Racket a C\n------------------\n(define cantNums 0)(define cantSpace 0)\n(define cad \"\")\n\t\t\t Vs.\nint i,j, contador_numeros=0, contador_espacios=0;\nchar cadena[20];\n------------------\n(string-copy! cad (read))\n\t\t\t Vs.\ngets(cadena);\n------------------\n(for ([i (in-range 0 (string-length cad) 1)])\n\t(for ([j (in-range 48 58 1)])\n\t\t(if (= (char->integer (string-ref cad i)) j)\n\t\t\t(set! cantNums (+ cantNums 1))\n\t\t)\n\t)\n\t(if (= (char->integer (string-ref cad i)) 32)\n\t\t(set! cantSpace (+ cantSpace 1))\n\t)\n)\n\t\t\t Vs.\nfor(i=0; i<strlen(cadena); i++){\n\tfor(j=48; j<58; j++){\n\t\tif(cadena[i]==j){\n\t\t\tcontador_numeros++;\n\t\t}\n\t}\n\tif(cadena[i]==32){\n\t\tcontador_espacios++;\n\t}\n}\n------------------",
                "2": "\t\t\tRACKET\nCADENAS:\nLas cadenas en Racket se definen como cualquier otra variable, se usa la palabra define y un identificador o nombre para dicha variable, seguidamente se inicializa la cadena entre comillas dobles \"\".\nSintácticamnete: \n(define cadena1 \"\")\n(define cadena2 \"Hola Mundo\")\n\nFunciones para cadenas:\n En Racket las funciones para el manejo de cadenas vienen nativas con el lenguaje, es decir, no hay que importar módulos o librerías.\n\nFOR:\nSe usa una variable para la cual se establece un rango de iteración. Se escribe la palabra reservada in-range y se coloca el inicio, el límite y la manera en que aumenta. Se separan por espacios en blanco.\nSintácticamente: \nfor(i (in-range inicio limite aumento))\n\nSELECCIÓN SIMPLE:\nLa sentencia if analiza una condición escrita entre paréntesis, en caso de ser verdadera ejecuta la primera sentencia, sino, ejecuta la segunda.\nSintácticamente:\n(if(condicion)\n\tcondicion_true\n\tcondicion_false\n)",
                "3": "\t\t\tC\nCADENAS:\nLas cadenas en C son un tipo de dato de char, solo que no almacena un solo caracter, sino que almacena varios caracteres en una sola variable, por lo que a nivel de sintaxis una cadena se declara así:\nchar cadena[]\nEs opcional ponerle el tamaño a la cadena, depende si se inicializa en el momento o no.\n*El caso especial para capturar cadenas por consola es que no se usa el ampersand & a la hora de colocar el nombre de la variable.\n\nFunciones para cadenas:\n En C existen librerías que permiten el manejo de funciones (copiar, concatenar, comparar, etc.) estas funciones se usan importando la librería: string.h \n\nFOR:\nSe usa una variable (i) para la cual se establece un inicio, límite y la manera en que aumenta. Se separan por punto y coma ; \nSintácticamente:\nfor(i=inicio; i<limite; i++){\n\tCuerpo de Bucle\n\t}\n\nSELECCIÓN SIMPLE:\nLa sentencia if evalua una condición escrita entre paréntesis y ejecuta la siguiente instrucción o conjunto de instrucciones.\nSintácticamente:\nif(condicion){\n\tBloque instrucciones\n}"
            },
            "5" : 
            {
                "1": "En este ejemplo se usa:\n\tCadenas\n\tEstructura de iteración: FOR\n\tCondicional Simple: IF\n\nDe Racket a C\n------------------\n(define cadena1 (string-copy (read)))\n(define cadena2 (make-string (string-length cadena1) #\\a))\n\t\t\t Vs.\nchar cadena1[20];\ngets(cadena1);\nchar cadena2[strlen(cadena1)];\nint tam=strlen(cadena1)-1;\n------------------\n(define tam (- (string-length cadena1) 1))\n\t\t\t Vs.\nint tam=strlen(cadena1)-1;\n------------------\n(for ([i (in-range 0 (string-length cadena1) 1)])\n\t(string-set! cadena2 tam (string-ref cadena1 i))\n\t(set! tam (- tam 1))\n)\n\t\t\t Vs.\nfor(int i=0; i<strlen(cadena1); i++) {\n\tcadena2[tam] = cadena1[i];\n\ttam--;\n}\n------------------\n(if (equal? cadena1 cadena2)\n\t(printf \"Es un palindromo.\")\n\t(printf \"No es un palindromo.\")\n)\n\t\t\t Vs.\nif (strcmp(cadena1, cadena2) == 0){\n\tprintf(\"\\nEs un palindromo.\\n\");\n}else printf(\"\\nNo es un palindromo.\\n\");\n------------------",
                "2": "\t\t\tRACKET\nCADENAS:\nLas cadenas en Racket se definen como cualquier otra variable, se usa la palabra define y un identificador o nombre para dicha variable, seguidamente se inicializa la cadena entre comillas dobles \"\".\nSintácticamnete: \n(define cadena1 \"\")\n(define cadena2 \"Hola Mundo\")\n\nFunciones para cadenas:\n En Racket las funciones para el manejo de cadenas vienen nativas con el lenguaje, es decir, no hay que importar módulos o librerías.\n\nFOR:\nSe usa una variable para la cual se establece un rango de iteración. Se escribe la palabra reservada in-range y se coloca el inicio, el límite y la manera en que aumenta. Se separan por espacios en blanco.\nSintácticamente: \nfor(i (in-range inicio limite aumento))\n\nSELECCIÓN SIMPLE:\nLa sentencia if analiza una condición escrita entre paréntesis, en caso de ser verdadera ejecuta la primera sentencia, sino, ejecuta la segunda.\nSintácticamente:\n(if(condicion)\n\tcondicion_true\n\tcondicion_false\n)",
                "3": "\t\t\tC\nCADENAS:\nLas cadenas en C son un tipo de dato de char, solo que no almacena un solo caracter, sino que almacena varios caracteres en una sola variable, por lo que a nivel de sintaxis una cadena se declara así:\nchar cadena[]\nEs opcional ponerle el tamaño a la cadena, depende si se inicializa en el momento o no.\n*El caso especial para capturar cadenas por consola es que no se usa el ampersand & a la hora de colocar el nombre de la variable.\n\nFunciones para cadenas:\n En C existen librerías que permiten el manejo de funciones (copiar, concatenar, comparar, etc.) estas funciones se usan importando la librería: string.h \n\nFOR:\nSe usa una variable (i) para la cual se establece un inicio, límite y la manera en que aumenta. Se separan por punto y coma ; \nSintácticamente:\nfor(i=inicio; i<limite; i++){\n\tCuerpo de Bucle\n\t}\n\nSELECCIÓN SIMPLE:\nLa sentencia if evalua una condición escrita entre paréntesis y ejecuta la siguiente instrucción o conjunto de instrucciones.\nSintácticamente:\nif(condicion){\n\tBloque instrucciones\n}"
            },
            "6" : 
            {
                "1": "En este ejemplo se usa:\n\tCadenas\n\nDe Racket a C\n------------------\n(define nombre (string-copy \"\"))\n(define apodo (string-copy \"\"))\n\t\t\t Vs.\nchar nombre[20];\nchar apodo[20];\n------------------\n(set! nombre (read))\n\t\t\t Vs.\nscanf(\"%s\", nombre);\n------------------\n(string-append nombre apodo)\n\t\t\t Vs.\nstrcat(nombre, apodo);\n-----------------",
                "2": "\t\t\tRACKET\nCADENAS:\nLas cadenas en Racket se definen como cualquier otra variable, se usa la palabra define y un identificador o nombre para dicha variable, seguidamente se inicializa la cadena entre comillas dobles \"\".\nSintácticamnete: \n(define cadena1 \"\")\n(define cadena2 \"Hola Mundo\")\n\nFunciones para cadenas:\n En Racket las funciones para el manejo de cadenas vienen nativas con el lenguaje, es decir, no hay que importar módulos o librerías.",
                "3": "\t\t\tC\nCADENAS:\nLas cadenas en C son un tipo de dato de char, solo que no almacena un solo caracter, sino que almacena varios caracteres en una sola variable, por lo que a nivel de sintaxis una cadena se declara así:\nchar cadena[]\nEs opcional ponerle el tamaño a la cadena, depende si se inicializa en el momento o no.\n*El caso especial para capturar cadenas por consola es que no se usa el ampersand & a la hora de colocar el nombre de la variable.\n\nFunciones para cadenas:\n En C existen librerías que permiten el manejo de funciones (copiar, concatenar, comparar, etc.) estas funciones se usan importando la librería: string.h "
            }
        },

        "vectores":
        {
            "1" : 
            {
                "1": "En este ejemplo se usa:\n\tVectores\n\tEstructura de iteración: FOR\n\nDe Racket a C\n------------------\n(define vect (vector 1 2 3))\n\t\t\t Vs.\nint vector[3]={1,2,3};\n------------------\n(for ([i (in-range 0 3 1)])\n\t(printf \"~a \" (vector-ref vect i))\n)\n\t\t\t Vs.\nfor(i=0; i<3; i++){\n\tprintf(\"%d \", vector[i]);\n}\n------------------\n(vector-set! vect 1 5)\n\t\t\t Vs.\nvector[1]=5;\n------------------",
                "2": "\t\t\tRACKET\nVECTORES:\nPara definir un vector en Racket, se usa la palabra reservada vector o make-vector y entre paréntesis se inicializan.\nLos vectores también se les tiene que definir un nombre, así que: \n(define vec (vector 1 2 3))\n\nFOR:\nSe usa una variable para la cual se establece un rango de iteración. Se escribe la palabra reservada in-range y se coloca el inicio, el límite y la manera en que aumenta. Se separan por espacios en blanco.\nSintácticamente: \nfor(i (in-range inicio limite aumento))",
                "3": "\t\t\tC\nVECTORES:\nLos vectores en C se declaran teniendo en cuenta:\n\tTipo de dato\n\tNombre\n\tTamaño.\nSintacticamente:\n tipo_dato nombre_vector[tamaño_vector];\n\nFOR:\nSe usa una variable (i) para la cual se establece un inicio, límite y la manera en que aumenta. Se separan por punto y coma ; \nSintácticamente:\nfor(i=inicio; i<limite; i++){\n\tCuerpo de Bucle\n\t}"
            },
            "2" : 
            {
                "1": "En este ejemplo se usa:\n\tVectores\n\tEstructura de iteración: FOR\n\nDe Racket a C\n------------------\n(define tam (read))\n\t\t\t Vs.\nscanf(\"%d\", &tamano);\n------------------\n(define vect (make-vector tam 0))\n\t\t\t Vs.\nint vector[tamano];\n------------------\n(for ([i (in-range 0 tam 1)])\n\t(printf \"Ingrese un valor entero para la posicion [~a]: \" i)\n\t(set! valor (read))\n\t(vector-set! vect i valor)\n)\n\t\t\t Vs.\nfor(i=0; i<tamano; i++){\n\tprintf(\"Ingrese un valor entero para la posicion [%d]: \", i);\n\tscanf(\"%d\", &valor);\n\tvector[i]=valor;\n}\n------------------\n(for ([i (in-range 0 tam 1)])\n\t(printf \"~a \" (vector-ref vect i))\n)\n\t\t\t Vs.\nfor(i=0; i<tamano;i++){\n\tprintf(\"%d \", vector[i]);\n}\n------------------",
                "2": "\t\t\tRACKET\nVECTORES:\nPara definir un vector en Racket, se usa la palabra reservada vector o make-vector y entre paréntesis se inicializan.\nLos vectores también se les tiene que definir un nombre, así que: \n(define vec (vector 1 2 3))\n\nFOR:\nSe usa una variable para la cual se establece un rango de iteración. Se escribe la palabra reservada in-range y se coloca el inicio, el límite y la manera en que aumenta. Se separan por espacios en blanco.\nSintácticamente: \nfor(i (in-range inicio limite aumento))",
                "3": "\t\t\tC\nVECTORES:\nLos vectores en C se declaran teniendo en cuenta:\n\tTipo de dato\n\tNombre\n\tTamaño.\nSintacticamente:\n tipo_dato nombre_vector[tamaño_vector];\n\nFOR:\nSe usa una variable (i) para la cual se establece un inicio, límite y la manera en que aumenta. Se separan por punto y coma ; \nSintácticamente:\nfor(i=inicio; i<limite; i++){\n\tCuerpo de Bucle\n\t}"
            },
            "3" : 
            {
                "1": "En este ejemplo se usa:\n\tVectores\n\tEstructura de iteración: FOR\n\nDe Racket a C\n------------------\n(define vect (vector 6 7 8 9 10))\n\t\t\t Vs.\nint vector[5]={6,7,8,9,10};\n------------------\n(for ([i (in-range 0 5 1)])\n\t(set! sumatoria (+ sumatoria (vector-ref vect i)))\n)\n\t\t\t Vs.\nfor(i=0; i<5; i++){\n\tsumatoria=vector[i]+sumatoria;\n}\n------------------",
                "2": "\t\t\tRACKET\nVECTORES:\nPara definir un vector en Racket, se usa la palabra reservada vector o make-vector y entre paréntesis se inicializan.\nLos vectores también se les tiene que definir un nombre, así que: \n(define vec (vector 1 2 3))\n\nFOR:\nSe usa una variable para la cual se establece un rango de iteración. Se escribe la palabra reservada in-range y se coloca el inicio, el límite y la manera en que aumenta. Se separan por espacios en blanco.\nSintácticamente: \nfor(i (in-range inicio limite aumento))",
                "3": "\t\t\tC\nVECTORES:\nLos vectores en C se declaran teniendo en cuenta:\n\tTipo de dato\n\tNombre\n\tTamaño.\nSintacticamente:\n tipo_dato nombre_vector[tamaño_vector];\n\nFOR:\nSe usa una variable (i) para la cual se establece un inicio, límite y la manera en que aumenta. Se separan por punto y coma ; \nSintácticamente:\nfor(i=inicio; i<limite; i++){\n\tCuerpo de Bucle\n\t}"
            },
            "4" : 
            {
                "1": "En este ejemplo se usa:\n\tVectores\n\tEstructura de iteración: FOR\n\nDe Racket a C\n------------------\n(define escalar 0)\n(define v1 (vector 2 3 4))\n(define v2 (vector 5 6 7))\n\t\t\t Vs.\nint i=0, escalar=0;\nint v1[3]={2,3,4};\nint v2[3]={5,6,7};\n------------------\n(for ([i (in-range 0 3 1)])\n\t(set! escalar (+ escalar (* (vector-ref v1 i) (vector-ref v2 i))))\n)\n\t\t\t Vs.\nfor(i=0; i<3; i++){\n\tescalar=(v1[i]*v2[i])+escalar;\n}\n------------------",
                "2": "\t\t\tRACKET\nVECTORES:\nPara definir un vector en Racket, se usa la palabra reservada vector o make-vector y entre paréntesis se inicializan.\nLos vectores también se les tiene que definir un nombre, así que: \n(define vec (vector 1 2 3))\n\nFOR:\nSe usa una variable para la cual se establece un rango de iteración. Se escribe la palabra reservada in-range y se coloca el inicio, el límite y la manera en que aumenta. Se separan por espacios en blanco.\nSintácticamente: \nfor(i (in-range inicio limite aumento))",
                "3": "\t\t\tC\nVECTORES:\nLos vectores en C se declaran teniendo en cuenta:\n\tTipo de dato\n\tNombre\n\tTamaño.\nSintacticamente:\n tipo_dato nombre_vector[tamaño_vector];\n\nFOR:\nSe usa una variable (i) para la cual se establece un inicio, límite y la manera en que aumenta. Se separan por punto y coma ; \nSintácticamente:\nfor(i=inicio; i<limite; i++){\n\tCuerpo de Bucle\n\t}"
            },
            "5" : 
            {
                "1": "En este ejemplo se usa:\n\tVectores\n\tEstructura de iteración: FOR\n\tCondicional Simple: IF\n\nDe Racket a C\n------------------\n(define vect (vector 1.2 3.0 0.2 5 7 4.1 9.99 10.2 4 2))\n\t\t\t Vs.\nfloat vector[10]={1.2, 3.0, 0.2, 5, 7, 4.1, 9.99, 10.2, 4, 2};\n------------------\n(for ([i (in-range 0 10 1)])\n\t(if (> (vector-ref vect i) (vector-ref vect max))\n\t(set! max i)\n\t(void)\n\t)\n)\n\t\t\t Vs.\nfor(i=0; i<10; i++){\n\tif(vector[i]>vector[max]){\n\tmax=i;\n\t}\n}\n------------------",
                "2": "\t\t\tRACKET\nVECTORES:\nPara definir un vector en Racket, se usa la palabra reservada vector o make-vector y entre paréntesis se inicializan.\nLos vectores también se les tiene que definir un nombre, así que: \n(define vec (vector 1 2 3))\n\nFOR:\nSe usa una variable para la cual se establece un rango de iteración. Se escribe la palabra reservada in-range y se coloca el inicio, el límite y la manera en que aumenta. Se separan por espacios en blanco.\nSintácticamente: \nfor(i (in-range inicio limite aumento))\n\nSELECCIÓN SIMPLE:\nLa sentencia if analiza una condición escrita entre paréntesis, en caso de ser verdadera ejecuta la primera sentencia, sino, ejecuta la segunda.\nSintácticamente:\n(if(condicion)\n\tcondicion_true\n\tcondicion_false\n)",
                "3": "\t\t\tC\nVECTORES:\nLos vectores en C se declaran teniendo en cuenta:\n\tTipo de dato\n\tNombre\n\tTamaño.\nSintacticamente:\n tipo_dato nombre_vector[tamaño_vector];\n\nFOR:\nSe usa una variable (i) para la cual se establece un inicio, límite y la manera en que aumenta. Se separan por punto y coma ; \nSintácticamente:\nfor(i=inicio; i<limite; i++){\n\tCuerpo de Bucle\n\t}\n\nSELECCIÓN SIMPLE:\nLa sentencia if evalua una condición escrita entre paréntesis y ejecuta la siguiente instrucción o conjunto de instrucciones.\nSintácticamente:\nif(condicion){\n\tBloque instrucciones\n}"
            },
            "6" : 
            {
                "1": "En este ejemplo se usa:\n\tVectores\n\tEstructura de iteración: FOR\n\tCondicional Simple: IF\n\nDe Racket a C\n------------------\n(define vect (vector -1.2 -3.0 0.2 5 7 -4.1 9.99 10.2 4 2))\n\t\t\t Vs.\nfloat vector[10]={-1.2, -3.0, 0.2, 5, 7, -4.1, 9.99, 10.2, 4, 2};\n------------------\n(for ([i (in-range 0 10 1)])\n\t(if (> (vector-ref vect i) 0)\n\t\t(set! negativos (+ negativos 1))\n\t\t(set! positivos (+ positivos 1))\n\t)\n)\n\t\t\t Vs.\nfor(i=0; i<10; i++){\n\tif(vector[i]<0){\n\t\tnegativos++;\n\t}else{\n\t\tpositivos++;\n\t}\n}\n------------------",
                "2": "\t\t\tRACKET\nVECTORES:\nPara definir un vector en Racket, se usa la palabra reservada vector o make-vector y entre paréntesis se inicializan.\nLos vectores también se les tiene que definir un nombre, así que: \n(define vec (vector 1 2 3))\n\nFOR:\nSe usa una variable para la cual se establece un rango de iteración. Se escribe la palabra reservada in-range y se coloca el inicio, el límite y la manera en que aumenta. Se separan por espacios en blanco.\nSintácticamente: \nfor(i (in-range inicio limite aumento))\n\nSELECCIÓN SIMPLE:\nLa sentencia if analiza una condición escrita entre paréntesis, en caso de ser verdadera ejecuta la primera sentencia, sino, ejecuta la segunda.\nSintácticamente:\n(if(condicion)\n\tcondicion_true\n\tcondicion_false\n)",
                "3": "\t\t\tC\nVECTORES:\nLos vectores en C se declaran teniendo en cuenta:\n\tTipo de dato\n\tNombre\n\tTamaño.\nSintacticamente:\n tipo_dato nombre_vector[tamaño_vector];\n\nFOR:\nSe usa una variable (i) para la cual se establece un inicio, límite y la manera en que aumenta. Se separan por punto y coma ; \nSintácticamente:\nfor(i=inicio; i<limite; i++){\n\tCuerpo de Bucle\n\t}\n\nSELECCIÓN SIMPLE:\nLa sentencia if evalua una condición escrita entre paréntesis y ejecuta la siguiente instrucción o conjunto de instrucciones.\nSintácticamente:\nif(condicion){\n\tBloque instrucciones\n}"
            }
        },

        "matrices":
        {
            "1" : 
            {
                "1": "En este ejemplo se usa:\n\tMatrices\n\tEstructura de iteración: FOR\n\nDe Racket a C\n------------------\n(define mat (make-matrix 3 4 0))\n\t\t\t Vs.\nint matriz[3][4];\n------------------\n(for ([i (in-range 0 3 1)])\n\t(for ([j (in-range 0 4 1)])\n\t\t(matrix-set mat i j (set! valor\n\t\t\t\t\t   (+ valor 1)))\n\t)\n)\n\t\t\tVs.\nfor(i=0; i<3; i++){\n\tfor(j=0; j<4; j++){\n\t\tmatriz[i][j]=valor++;\n\t}\n}\n------------------",
                "2": "\t\t\tRACKET\nMATRICES:\nPara el manejo de matrices en racket es necesario importar o requerir el módulo math/matrix\nDicho módulo contiene funciones para crear y llenar matrices.\nLas matrices se definen como una variable más en Racket, se usa la palabra define y se le da un identificador.\nSintácticamente:\n(require math/matrix)\n(define matriz (make-matrix fil col 0))\n\nFOR:\nSe usa una variable para la cual se establece un rango de iteración. Se escribe la palabra reservada in-range y se coloca el inicio, el límite y la manera en que aumenta. Se separan por espacios en blanco.\nSintácticamente: \nfor(i (in-range inicio limite aumento))",
                "3": "\t\t\tC\nMATRICES:\nLas matrices en C se consideran un vector bidimensional, por lo que se declaran de igual manera, solo que en vez de proporcionar un tamaño, se proporciona un número de alto y ancho, para las filas y columnas respectivamente, así que hablando sintácticamente:\ntipo_dato nombre_matriz[filas][Columnas];\n\nFOR:\nSe usa una variable (i) para la cual se establece un inicio, límite y la manera en que aumenta. Se separan por punto y coma ; \nSintácticamente:\nfor(i=inicio; i<limite; i++){\n\tCuerpo de Bucle\n\t}"
            },
            "2" : 
            {
                "1": "En este ejemplo se usa:\n\tMatrices\n\tEstructura de iteración: FOR\n\nDe Racket a C\n-------------------\n(for ([i (in-range 0 fil 1)])\n\t(for ([j (in-range 0 col 1)])\n\t\t(printf \"Pos [~a] [~a]: \" i j)\n\t\t(set! dato (read))\n\t\t(matrix-set mat i j dato)\n\t)\n)\n\t\t\t\tVs.\nfor(i=0; i<filas; i++){\n\tfor(j=0; j<columnas; j++){\n\t\tprintf(\"Pos[%d] [%d]: \", i, j);\n\t\tscanf(\"%d\", &dato);\n\t\tmatriz[i][j]=dato;\n\t}\n}\n-------------------",
                "2": "\t\t\tRACKET\nMATRICES:\nPara el manejo de matrices en racket es necesario importar o requerir el módulo math/matrix\nDicho módulo contiene funciones para crear y llenar matrices.\nLas matrices se definen como una variable más en Racket, se usa la palabra define y se le da un identificador.\nSintácticamente:\n(require math/matrix)\n(define matriz (make-matrix fil col 0))\n\nFOR:\nSe usa una variable para la cual se establece un rango de iteración. Se escribe la palabra reservada in-range y se coloca el inicio, el límite y la manera en que aumenta. Se separan por espacios en blanco.\nSintácticamente: \nfor(i (in-range inicio limite aumento))",
                "3": "\t\t\tC\nMATRICES:\nLas matrices en C se consideran un vector bidimensional, por lo que se declaran de igual manera, solo que en vez de proporcionar un tamaño, se proporciona un número de alto y ancho, para las filas y columnas respectivamente, así que hablando sintácticamente:\ntipo_dato nombre_matriz[filas][Columnas];\n\nFOR:\nSe usa una variable (i) para la cual se establece un inicio, límite y la manera en que aumenta. Se separan por punto y coma ; \nSintácticamente:\nfor(i=inicio; i<limite; i++){\n\tCuerpo de Bucle\n\t}"
            },
            "3" : 
            {
                "1": "En este ejemplo se usa:\n\tMatrices\n\tEstructura de iteración: FOR\n\nDe Racket a C\n------------------\n(for ([i (in-range 0 fil 1)])\n\t(for ([j (in-range 0 col 1)])\n\t\t(printf \"Pos [~a] [~a]: \" i j)\n\t\t(set! dato (read))\n\t\t(matrix-set mat i j dato)\n\t)\n)\n\t\t\tVs.\nfor(i=0; i<filas; i++){\n\tfor(j=0; j<columnas; j++){\n\t\tprintf(\"Pos [%d] [%d]: \", i, j);\n\t\tscanf(\"%d\", &dato);\n\t\tmatriz1[i][j]=dato;\n\t}\n}\n------------------",
                "2": "\t\t\tRACKET\nMATRICES:\nPara el manejo de matrices en racket es necesario importar o requerir el módulo math/matrix\nDicho módulo contiene funciones para crear y llenar matrices.\nLas matrices se definen como una variable más en Racket, se usa la palabra define y se le da un identificador.\nSintácticamente:\n(require math/matrix)\n(define matriz (make-matrix fil col 0))\n\nFOR:\nSe usa una variable para la cual se establece un rango de iteración. Se escribe la palabra reservada in-range y se coloca el inicio, el límite y la manera en que aumenta. Se separan por espacios en blanco.\nSintácticamente: \nfor(i (in-range inicio limite aumento))",
                "3": "\t\t\tC\nMATRICES:\nLas matrices en C se consideran un vector bidimensional, por lo que se declaran de igual manera, solo que en vez de proporcionar un tamaño, se proporciona un número de alto y ancho, para las filas y columnas respectivamente, así que hablando sintácticamente:\ntipo_dato nombre_matriz[filas][Columnas];\n\nFOR:\nSe usa una variable (i) para la cual se establece un inicio, límite y la manera en que aumenta. Se separan por punto y coma ; \nSintácticamente:\nfor(i=inicio; i<limite; i++){\n\tCuerpo de Bucle\n\t}"
            },
            "4" : 
            {
                "1": "En este ejemplo se usa:\n\tMatrices\n\tEstructura de iteración: FOR\n\nDe Racket a C\n------------------\n(define fil (read))\n\t\t\t Vs.\nscanf(\"%d\", &filas);\n------------------\n(define numeros (make-matrix fil 12 0))\n\t\t\t Vs.\nchar numeros[filas][12];\n------------------\n(printf \"***BASE DE DATOS: ***\")\n(for ([i (in-range 0 fil 1)])\n\t(for ([j (in-range 0 2 1)])\n\t   (printf \"Nombre: ~a | Telefono: ~a\" \n\t   (matrix-ref nombres i j) \n\t   (matrix-ref numeros i j))\n\t)\n)\n\t\t\t Vs.\nprintf(.\"***BASE DE DATOS: ***.\");\nfor(i=0; i<filas; i++){\n   printf(.\"Nombre: %s | Telefono: %s.\", \n   nombres[i], \n   numeros[i]);\n}\n------------------",
                "2": "\t\t\tRACKET\nMATRICES:\nPara el manejo de matrices en racket es necesario importar o requerir el módulo math/matrix\nDicho módulo contiene funciones para crear y llenar matrices.\nLas matrices se definen como una variable más en Racket, se usa la palabra define y se le da un identificador.\nSintácticamente:\n(require math/matrix)\n(define matriz (make-matrix fil col 0))\n\nFOR:\nSe usa una variable para la cual se establece un rango de iteración. Se escribe la palabra reservada in-range y se coloca el inicio, el límite y la manera en que aumenta. Se separan por espacios en blanco.\nSintácticamente: \nfor(i (in-range inicio limite aumento))",
                "3": "\t\t\tC\nMATRICES:\nLas matrices en C se consideran un vector bidimensional, por lo que se declaran de igual manera, solo que en vez de proporcionar un tamaño, se proporciona un número de alto y ancho, para las filas y columnas respectivamente, así que hablando sintácticamente:\ntipo_dato nombre_matriz[filas][Columnas];\n\nFOR:\nSe usa una variable (i) para la cual se establece un inicio, límite y la manera en que aumenta. Se separan por punto y coma ; \nSintácticamente:\nfor(i=inicio; i<limite; i++){\n\tCuerpo de Bucle\n\t}"
            },
            "5" : 
            {
                "1": "En este ejemplo se usa:\n\tMatrices\n\tEstructura de iteración: FOR\n\tCondicional Simple: IF\n\nDe Racket a C\n------------------\n(set! fil (read))\n\t\t\tVs.\nscanf(\"%d\", &filas);\n------------------\n(define paciente (make-matrix fil 50 0))\n\t\t\tVs.\nchar paciente[filas][50];\n------------------\n(define fecha (make-matrix fil 4 0))\n\t\t\tVs.\nint fecha[filas][4];\nfor(i=0; i<filas; i++){\n\tfor(j=0; j<4; j++){\n\t\tfecha[i][j]=0;\n\t}\n}\n------------------",
                "2": "\t\t\tRACKET\nMATRICES:\nPara el manejo de matrices en racket es necesario importar o requerir el módulo math/matrix\nDicho módulo contiene funciones para crear y llenar matrices.\nLas matrices se definen como una variable más en Racket, se usa la palabra define y se le da un identificador.\nSintácticamente:\n(require math/matrix)\n(define matriz (make-matrix fil col 0))\n\nFOR:\nSe usa una variable para la cual se establece un rango de iteración. Se escribe la palabra reservada in-range y se coloca el inicio, el límite y la manera en que aumenta. Se separan por espacios en blanco.\nSintácticamente: \nfor(i (in-range inicio limite aumento))\n\nSELECCIÓN SIMPLE:\nLa sentencia if analiza una condición escrita entre paréntesis, en caso de ser verdadera ejecuta la primera sentencia, sino, ejecuta la segunda.\nSintácticamente:\n(if(condicion)\n\tcondicion_true\n\tcondicion_false\n)",
                "3": "\t\t\tC\nMATRICES:\nLas matrices en C se consideran un vector bidimensional, por lo que se declaran de igual manera, solo que en vez de proporcionar un tamaño, se proporciona un número de alto y ancho, para las filas y columnas respectivamente, así que hablando sintácticamente:\ntipo_dato nombre_matriz[filas][Columnas];\n\nFOR:\nSe usa una variable (i) para la cual se establece un inicio, límite y la manera en que aumenta. Se separan por punto y coma ; \nSintácticamente:\nfor(i=inicio; i<limite; i++){\n\tCuerpo de Bucle\n\t}\n\nSELECCIÓN SIMPLE:\nLa sentencia if evalua una condición escrita entre paréntesis y ejecuta la siguiente instrucción o conjunto de instrucciones.\nSintácticamente:\nif(condicion){\n\tBloque instrucciones\n}"
            },
            "6" : 
            {
                "1": "En este ejemplo se usa:\n\tMatrices\n\tEstructura de iteración: FOR\n\tCondicional Simple: IF\n\tEstructura de iteración: DO (Racket) / DO WHILE (C)\n\nDe Racket a C.\n------------------\n(printf \"módulos Ocupados \")\n(for ([i (in-range 0 fil 1)])\n\t(if (= (matrix-ref parqueadero i 1) 1)\n\t\t(printf \"módulo [~a]\" i+1)\n\t)\n)\n\t\t\tVs.\nprintf(\"módulos Ocupados: \");\nfor(i=0; i<filas; i++){\n\tif(parqueadero[i][1]==1){\n\t\tprintf(\"módulo [%d]\", i+1);\n\t}\n}\n------------------",
                "2": "\t\t\tRACKET\nMATRICES:\nPara el manejo de matrices en racket es necesario importar o requerir el módulo math/matrix\nDicho módulo contiene funciones para crear y llenar matrices.\nLas matrices se definen como una variable más en Racket, se usa la palabra define y se le da un identificador.\nSintácticamente:\n(require math/matrix)\n(define matriz (make-matrix fil col 0))\n\nFOR:\nSe usa una variable para la cual se establece un rango de iteración. Se escribe la palabra reservada in-range y se coloca el inicio, el límite y la manera en que aumenta. Se separan por espacios en blanco.\nSintácticamente: \nfor(i (in-range inicio limite aumento))\n\nSELECCIÓN SIMPLE:\nLa sentencia if analiza una condición escrita entre paréntesis, en caso de ser verdadera ejecuta la primera sentencia, sino, ejecuta la segunda.\nSintácticamente:\n(if(condicion)\n\tcondicion_true\n\tcondicion_false\n)\n\nDO:\nLa estructura repetitiva que ejecuta instrucciones y luego evalua en Racket se define por la palabra reservada do, sintácticamnete se coloca entre paréntesis la palabra do y se usa una variable para la cual se establece un inicio, la manera como incrementa y un límite.\nSintácticamnete:\nSea v la variable a iterar: \n(d (v inicio (+ v incremento)) (< v limite)\n\tInstrucciones\n))",
                "3": "\t\t\tC\nMATRICES:\nLas matrices en C se consideran un vector bidimensional, por lo que se declaran de igual manera, solo que en vez de proporcionar un tamaño, se proporciona un número de alto y ancho, para las filas y columnas respectivamente, así que hablando sintácticamente:\ntipo_dato nombre_matriz[filas][Columnas];\n\nFOR:\nSe usa una variable (i) para la cual se establece un inicio, límite y la manera en que aumenta. Se separan por punto y coma ; \nSintácticamente:\nfor(i=inicio; i<limite; i++){\n\tCuerpo de Bucle\n\t}\n\nSELECCIÓN SIMPLE:\nLa sentencia if evalua una condición escrita entre paréntesis y ejecuta la siguiente instrucción o conjunto de instrucciones.\nSintácticamente:\nif(condicion){\n\tBloque instrucciones\n}\n\nDO WHILE:\nEn C, la estructura repetitiva que ejecuta instrucciones y luego evalua se llama do-while. Se usa las palabras reservadas do y while, y entre corchetes se escribe las instrucciones a repetir, se finaliza con ;\nSintácticamente:\ndo{\n\tInstrucciones\n}while(condicion);"
            }
        },

        "estructuras":
        {
            "1" : 
            {
                "1": "En este ejemplo se usa:\n\tEstructuras\n\nDe Racket a C\n------------------\n(define-struct fecha(\n\t\tdia\n\t\tmes\n\t\tanio\n\t)\n)\n\t\t\t Vs\nstruct fecha{\n\tint dia;\n\tint mes;\n\tint anio;\n};\n------------------\n(printf \"Ingrese la fecha de nacimiento: \")\n(define Nacimiento(make-fecha\n\t(begin (printf \"\\nDia: \")(read))\n\t(begin (printf \"\\nMes: \")(read))\n\t(begin (printf \"\\nAnio: \")(read))\n    )\n)\n\t\t\t Vs\nprintf(\"Ingrese una fecha de \n\t\tnacimiento:\\nDia: \");\nscanf(\"%d\", &Nacimiento.dia);\nprintf(\"Mes: \");\nscanf(\"%d\", &Nacimiento.mes);\nprintf(\"Anio: \");\nscanf(\"%d\", &Nacimiento.anio);\n------------------",
                "2": "\t\t\tRACKET\nESTRUCTURAS\nPara definir una estructura en Racket se usa un caso especial de la palabra reservada define. Se usa la palabra: define-struct y se le da un nombre para la estructura, seguidamente entre paréntesis se colocan las variables correspondientes a los miembros de la estructura.\nSintácticamnete:\n(define-struct nombre_estructura(\n\tmiembro_1\n\tmiembro_2\n\t)\n)",
                "3": "\t\t\tC\nESTRUCTURAS:\nEn C las estructuras se definen con la palabra reservada struct y entre llaves se ingresan todos los miembros de dicha estructura, cada miembro debe tener declarado su tipo de dato y su nombre. Una vez finalizado esto, luego de las llaves se puede realizar la creación de una variable del tipo de dicha estructura o simplemente colocar el símbolo ;\n\nSintacticamnete:\nstruct nombre_estructura{\n\tint numero;\n\tint vector[20]\n}variable_de_estrucutra;"
            },
            "2" : 
            {
                "1": "En este ejemplo se usa:\n\tEstructuras\n \n De Racket a C\n------------------\n(define-struct DataPerson(\n\t\tnombre\n\t\tapellido\n\t\tcedula\n\t)\n )\n\t\t\tVs\nstruct datos_persona{\n\tchar nombre[20];\n\tchar apellido[20];\n\tchar cedula[12];\n};\n ------------------",
                "2": "\t\t\tRACKET\nESTRUCTURAS\nPara definir una estructura en Racket se usa un caso especial de la palabra reservada define. Se usa la palabra: define-struct y se le da un nombre para la estructura, seguidamente entre paréntesis se colocan las variables correspondientes a los miembros de la estructura.\nSintácticamnete:\n(define-struct nombre_estructura(\n\tmiembro_1\n\tmiembro_2\n\t)\n)",
                "3": "\t\t\tC\nESTRUCTURAS:\nEn C las estructuras se definen con la palabra reservada struct y entre llaves se ingresan todos los miembros de dicha estructura, cada miembro debe tener declarado su tipo de dato y su nombre. Una vez finalizado esto, luego de las llaves se puede realizar la creación de una variable del tipo de dicha estructura o simplemente colocar el símbolo ;\n\nSintacticamnete:\nstruct nombre_estructura{\n\tint numero;\n\tint vector[20]\n}variable_de_estrucutra;"
            },
            "3" : 
            {
                "1": "En este ejemplo se usa:\n\tEstructuras\n\nDe Racket a C\n------------------\n(define-struct fecha(\n\t\tdia\n\t\tmes\n\t\tanio\n\t)\n)\n\n(define-struct DataPerson(\n \t\tnombre\n \t\tapellido\n\t\tcedula\n\t\tFECHA\n\t)\n)\n\t\t\tVs\nstruct fecha{\n\tint dia;\n\tint mes;\n\tint anio;\n};\n\nstruct datos_persona{\n\tchar nombre[20];\n\tchar apellido[20];\n\tchar cedula[12];\n\tstruct fecha fecha_Nacimiento;\n};\n------------------\n(printf \" ~a/\"(fecha-dia (DataPerson-\n\t\tFECHA Persona)))\n\t\t\tVs\nprintf(\"%d/\",\n\tPersona1.fecha_Nacimiento.dia);\n------------------",
                "2": "\t\t\tRACKET\nESTRUCTURAS\nPara definir una estructura en Racket se usa un caso especial de la palabra reservada define. Se usa la palabra: define-struct y se le da un nombre para la estructura, seguidamente entre paréntesis se colocan las variables correspondientes a los miembros de la estructura.\nSintácticamnete:\n(define-struct nombre_estructura(\n\tmiembro_1\n\tmiembro_2\n\t)\n)",
                "3": "\t\t\tC\nESTRUCTURAS:\nEn C las estructuras se definen con la palabra reservada struct y entre llaves se ingresan todos los miembros de dicha estructura, cada miembro debe tener declarado su tipo de dato y su nombre. Una vez finalizado esto, luego de las llaves se puede realizar la creación de una variable del tipo de dicha estructura o simplemente colocar el símbolo ;\n\nSintacticamnete:\nstruct nombre_estructura{\n\tint numero;\n\tint vector[20]\n}variable_de_estrucutra;"
            },
            "4" : 
            {
                "1": "En este ejemplo se usa:\n\tEstructuras\n\nDe Racket a C\n------------------\n(set! hora (- (hora-horas Hora2) \t\t(hora-horas Hora1)))(if(< hora 0)\n\t(set! hora (* hora -1))\n\t(void)\n)\n\t\t\tVs.\nhora=Hora2.horas-Hora1.horas;\nif(hora<0){\n\thora=hora*-1;\n}\n------------------",
                "2": "\t\t\tRACKET\nESTRUCTURAS\nPara definir una estructura en Racket se usa un caso especial de la palabra reservada define. Se usa la palabra: define-struct y se le da un nombre para la estructura, seguidamente entre paréntesis se colocan las variables correspondientes a los miembros de la estructura.\nSintácticamnete:\n(define-struct nombre_estructura(\n\tmiembro_1\n\tmiembro_2\n\t)\n)",
                "3": "\t\t\tC\nESTRUCTURAS:\nEn C las estructuras se definen con la palabra reservada struct y entre llaves se ingresan todos los miembros de dicha estructura, cada miembro debe tener declarado su tipo de dato y su nombre. Una vez finalizado esto, luego de las llaves se puede realizar la creación de una variable del tipo de dicha estructura o simplemente colocar el símbolo ;\n\nSintacticamnete:\nstruct nombre_estructura{\n\tint numero;\n\tint vector[20]\n}variable_de_estrucutra;"
            },
            "5" : 
            {
                "1": "En este ejemplo se usa:\n\tEstructuras\n\tVectores\n\nDe Racket a C\n------------------\n(define empleado (make-vector nemp))\n\t\t\tVs.\nstruct Persona emp[nemp];\n------------------\n(for ([i (in-range 0 nemp 1)])\n\t\t\tVs.\nfor(i=0;i<nemp;i++){\n------------------\n(begin (printf \"\\nNombre[~a]: \"\n\t\t(+ i 1))(read))\n\t\t\tVs.\nprintf(\"\\nNombre[%d]: \",i+1);\nscanf(\"%s\",emp[i].nombre);\n------------------",
                "2": "\t\t\tRACKET\nESTRUCTURAS\nPara definir una estructura en Racket se usa un caso especial de la palabra reservada define. Se usa la palabra: define-struct y se le da un nombre para la estructura, seguidamente entre paréntesis se colocan las variables correspondientes a los miembros de la estructura.\nSintácticamnete:\n(define-struct nombre_estructura(\n\tmiembro_1\n\tmiembro_2\n\t)\n)\n\nVECTORES:\nPara definir un vector en Racket, se usa la palabra reservada vector o make-vector y entre paréntesis se inicializan.\nLos vectores también se les tiene que definir un nombre, así que: \n(define vec (vector 1 2 3))",
                "3": "\t\t\tC\nESTRUCTURAS:\nEn C las estructuras se definen con la palabra reservada struct y entre llaves se ingresan todos los miembros de dicha estructura, cada miembro debe tener declarado su tipo de dato y su nombre. Una vez finalizado esto, luego de las llaves se puede realizar la creación de una variable del tipo de dicha estructura o simplemente colocar el símbolo ;\n\nSintacticamnete:\nstruct nombre_estructura{\n\tint numero;\n\tint vector[20]\n}variable_de_estrucutra;\n\nVECTORES:\nLos vectores en C se declaran teniendo en cuenta:\n\tTipo de dato\n\tNombre\n\tTamaño.\nSintacticamente:\n tipo_dato nombre_vector[tamaño_vector];"
            },
            "6" : 
            {
                "1": "En este ejemplo se usa:\n\tEstructuras\n\tVectores\n\nDe Racket a C\n------------------\n(define-struct persona(\n\t\tnombre\n\t\tcedula\n\t)\n)\n\t\t\tVs.\nstruct persona{\n\tchar nombre[30];\n\tint cedula;\n};\n------------------\n(for ([i (in-range 0 n_personas 1)])\n\t(vector-set! personas i \n\t\t(make-persona\n\t\t\t(begin (printf \n\t\t\t\"\\nNombre[~a]: \" \n\t\t\t\t(+ i 1))(read))\n\t\t\t(begin (printf \n\t\t\t\"\\nCedula[~a]: \" \n\t\t\t\t(+ i 1))(read))\n\t\t)\n\t)\n)\n\t\t\tVs.\nfor(i=0;i<n_personas;i++){\n\tprintf(\"\\nNombre[%d]: \",i+1);\n\tscanf(\"%s\",personas[i].nombre);\n\tprintf(\"Cedula[%d]: \",i+1);\n\tscanf(\"%d\", &personas[i].cedula);\n}------------------",
                "2": "\t\t\tRACKET\nESTRUCTURAS\nPara definir una estructura en Racket se usa un caso especial de la palabra reservada define. Se usa la palabra: define-struct y se le da un nombre para la estructura, seguidamente entre paréntesis se colocan las variables correspondientes a los miembros de la estructura.\nSintácticamnete:\n(define-struct nombre_estructura(\n\tmiembro_1\n\tmiembro_2\n\t)\n)\n\nVECTORES:\nPara definir un vector en Racket, se usa la palabra reservada vector o make-vector y entre paréntesis se inicializan.\nLos vectores también se les tiene que definir un nombre, así que: \n(define vec (vector 1 2 3))",
                "3": "\t\t\tC\nESTRUCTURAS:\nEn C las estructuras se definen con la palabra reservada struct y entre llaves se ingresan todos los miembros de dicha estructura, cada miembro debe tener declarado su tipo de dato y su nombre. Una vez finalizado esto, luego de las llaves se puede realizar la creación de una variable del tipo de dicha estructura o simplemente colocar el símbolo ;\n\nSintacticamnete:\nstruct nombre_estructura{\n\tint numero;\n\tint vector[20]\n}variable_de_estrucutra;\n\nVECTORES:\nLos vectores en C se declaran teniendo en cuenta:\n\tTipo de dato\n\tNombre\n\tTamaño.\nSintacticamente:\n tipo_dato nombre_vector[tamaño_vector];"
            }
        },

        "funciones":
        {
            "1" : 
            {
                "1": "En este ejemplo se usa:\n\tFunciones\n\nDe Racket a C\n-------------------\n(define (esperar n)\n\t(if (= (remainder n 2) 0)\n\t\t1\n\t\t0\n\t)\n)\n\t\t\tVs.\nint espar(int n){\n\tif(n%2==0){\n\t\treturn 1;\n\t}else return 0;\n}\n-------------------\n(if (= (esperar numero) 1)\n\t\t\tVs.\nif(espar(numero) == 1){\n-------------------",
                "2": "\t\t\tRACKET\nFUNCIONES:\nEn Racket basta con escribir la palabra reservada define y seguido dar un nombre o identificador para la función, a continuación se escriben sus parametros y las instrucciones correspondientes.\nSintácticamente: (define nombre_funcion (num1 num2)\nInstrucciones\n)",
                "3": "\t\t\tC\nFUNCIONES:\nEn C el definir funciones es algo sencillo pero especifico, se debe tener en cuenta el tipo de dato que la función retornará y el tipo de dato de los parametros de entrada.\nSintácticamente:\n tipo_dato_salida nombre_funcion (tipo_dato_entrada entrada1, tipo_dato_entrada entrada2){\n\tInstrucciones\n}"
            },
            "2" : 
            {
                "1": "En este ejemplo se usa:\n\tFunciones\n\nDe Racket a C\n-------------------\n(define (descuento precio descuento)\n\t(define total 0)\n\t(if(and (> precio 0) (> descuento 0))\n\t\t(set! total (* precio\n\t\t(/ (- 100 descuento) 100)))\n\t)\n\ttotal\n)\n\t\t\tVs.\nfloat descuento(float precio, float\ndescuento){\n\tfloat total=0;\n\tif(precio>0 && descuento>0){\n\t\ttotal=precio*(\n\t\t(100-descuento)/100);\n\t}\n\treturn total;\n}\n-------------------\n(printf \"El precio final es: ~a\" \n\t\t(descuento precio desc))\n\t\t\tVs.\nprintf(\"El precio final es: %.2f\",\n\t\tdescuento(precio, desc));\n-------------------",
                "2": "\t\t\tRACKET\nFUNCIONES:\nEn Racket basta con escribir la palabra reservada define y seguido dar un nombre o identificador para la función, a continuación se escriben sus parametros y las instrucciones correspondientes.\nSintácticamente: (define nombre_funcion (num1 num2)\nInstrucciones\n)",
                "3": "\t\t\tC\nFUNCIONES:\nEn C el definir funciones es algo sencillo pero especifico, se debe tener en cuenta el tipo de dato que la función retornará y el tipo de dato de los parametros de entrada.\nSintácticamente:\n tipo_dato_salida nombre_funcion (tipo_dato_entrada entrada1, tipo_dato_entrada entrada2){\n\tInstrucciones\n}"
            },
            "3" : 
            {
                "1": "En este ejemplo se usa:\n\tFunciones\n\nDe Racket a C\n-------------------\n(for ([i (in-range 0 N 1)])\n\t(if (< mayor (vector-ref vect i))\n\t\t(set! mayor (vector-ref vect i))\n\t\t(void)\n\t)\n)\nmayor\n\t\t\tVs.\nfor(i=0; i<N; i++){\n\tif(mayor<vector[i]){\n\t\tmayor=vector[i];\n\t}\n}\nreturn mayor;\n-------------------",
                "2": "\t\t\tRACKET\nFUNCIONES:\nEn Racket basta con escribir la palabra reservada define y seguido dar un nombre o identificador para la función, a continuación se escriben sus parametros y las instrucciones correspondientes.\nSintácticamente: (define nombre_funcion (num1 num2)\nInstrucciones\n)",
                "3": "\t\t\tC\nFUNCIONES:\nEn C el definir funciones es algo sencillo pero especifico, se debe tener en cuenta el tipo de dato que la función retornará y el tipo de dato de los parametros de entrada.\nSintácticamente:\n tipo_dato_salida nombre_funcion (tipo_dato_entrada entrada1, tipo_dato_entrada entrada2){\n\tInstrucciones\n}"
            },
            "4" : 
            {
                "1": "En este ejemplo se usa:\n\tFunciones\n\nDe Racket a C\n--------------------\n(cond\n\t((= opcion 1)\n\t\t\tVs.\nswitch(opcion){\n\tcase 1: \n--------------------\nint resta(){\tint a, b;\tprintf(\"Numero a:\");\tscanf(\"%d\", &a);\tprintf(\"\nNumero b: \");\tscanf(\"%d\", &b);\treturn a-b;}\t\t\tVs.\nint resta(){\tint a, b;\tprintf(\"Numero a: \");\tscanf(\"%d\", &a);\tprintf(\"Numero b:\");\tscanf(\"%d\", &b);\treturn a-b;}\n--------------------",
                "2": "\t\t\tRACKET\nFUNCIONES:\nEn Racket basta con escribir la palabra reservada define y seguido dar un nombre o identificador para la función, a continuación se escriben sus parametros y las instrucciones correspondientes.\nSintácticamente: (define nombre_funcion (num1 num2)\nInstrucciones\n)",
                "3": "\t\t\tC\nFUNCIONES:\nEn C el definir funciones es algo sencillo pero especifico, se debe tener en cuenta el tipo de dato que la función retornará y el tipo de dato de los parametros de entrada.\nSintácticamente:\n tipo_dato_salida nombre_funcion (tipo_dato_entrada entrada1, tipo_dato_entrada entrada2){\n\tInstrucciones\n}"
            },
            "5" : 
            {
                "1": "En este ejemplo se usa:\n\tFunciones\n\tRecursividad\n\nDe Racket a C\n--------------------\n(printf  \"El factorial del numero ~a es: ~a \" \n\tnumero (factorial numero))\n\t\t\tVs.\nprintf(\"El factorial del numero %d es: \n%d.\",\nnumero, factorial(numero));\n--------------------\n(define (factorial n)\n\t(if(= n 0)\n\t\t1\n\t\t(if(= n 1)\n\t\t\t1\n\t\t\t(* n (factorial (- n 1)))\n\t\t)\n\t)\n)\n\t\t\tVs.\nint factorial(int n) {\n\tif(n < 0) return 0;\n\telse if(n > 1) return n*factorial(n-1);\n\treturn 1;\n}\n--------------------",
                "2": "\t\t\tRACKET\nFUNCIONES:\nEn Racket basta con escribir la palabra reservada define y seguido dar un nombre o identificador para la función, a continuación se escriben sus parametros y las instrucciones correspondientes.\nSintácticamente: (define nombre_funcion (num1 num2)\nInstrucciones\n)",
                "3": "\t\t\tC\nFUNCIONES:\nEn C el definir funciones es algo sencillo pero especifico, se debe tener en cuenta el tipo de dato que la función retornará y el tipo de dato de los parametros de entrada.\nSintácticamente:\n tipo_dato_salida nombre_funcion (tipo_dato_entrada entrada1, tipo_dato_entrada entrada2){\n\tInstrucciones\n}"
            },
            "6" : 
            {
                "1": "En este ejemplo se usa:\n\tFunciones\n\tRecursividad\n\nDe Racket a C\n------------------\n(define (fibonacci n)\n\t(if (= n 1)\n\t\t1\n\t\t(if (= n 2)\n\t\t\t1\n\t\t\t(+ (fibonacci (- n 1))\n\t\t\t(fibonacci (- n 2)))\n\t\t)\n\t)\n)\n\t\t\tVs.\nint fibonacci(int n){\n\tif (n == 1){\n\t\treturn 1;\n\t}else if (n==2){\n\t\treturn 1;\n\t}else return fibonacci(n-1) +\n\t\t\t\tfibonacci(n-2);\n}\n------------------",
                "2": "\t\t\tRACKET\nFUNCIONES:\nEn Racket basta con escribir la palabra reservada define y seguido dar un nombre o identificador para la función, a continuación se escriben sus parametros y las instrucciones correspondientes.\nSintácticamente: (define nombre_funcion (num1 num2)\nInstrucciones\n)",
                "3": "\t\t\tC\nFUNCIONES:\nEn C el definir funciones es algo sencillo pero especifico, se debe tener en cuenta el tipo de dato que la función retornará y el tipo de dato de los parametros de entrada.\nSintácticamente:\n tipo_dato_salida nombre_funcion (tipo_dato_entrada entrada1, tipo_dato_entrada entrada2){\n\tInstrucciones\n}"
            }
        },

        "composicion":
        {
            "1" : 
            {
                "1": "En este ejemplo se usa:\n\tComposición de Funciones\n\nDe Racket a C\n------------------\n(set! valor (ASCII letra))\n\t\t\tVs.\nvalor=ASCII(letra);\n------------------\n(define (ASCII letra)\n\t(char->integer letra)\n)\n\t\t\tVs.\nint ASCII(char letra){\n\treturn letra;\n}\n------------------",
                "2": "\t\t\tRACKET\nCOMPOSICIÓN DE FUNCIONES\nEn Racket es posible anidar funciones, es decir, tener una función en la cual se tenga el llamado a otra función u otras funciones. Esto se hace con el propósito de unir funciones para lograr un solo objetivo.",
                "3": "\t\t\tC\nCOMPOSICIÓN DE FUNCIONES\nEn C existen llamados a funciones dentro de otras, esto se llama composición o anidación de funciones. Cada función retorna un valor que es usado en la función donde se realiza el llamado, esto para lograr un objetivo específico."
            },
            "2" : 
            {
                "1": "En este ejemplo se usa:\n\tComposición de Funciones\n\nDe Racket a C\n------------------\n(if(= (mayor a b) a)\n\t(- a b)\n\t-1\n)\n\t\t\tVs.\nif(mayor(a,b)==a){\n\treturn a-b;\n}else return -1;\n------------------\n(define (mayor a b)\n\t(if(> b a) \n\t\tb\n\t\ta\n\t)\n)\n\t\t\tVs.\nint mayor(int a, int b){\n\tif(b>a) return b;\n\telse return a;\n}\n------------------",
                "2": "\t\t\tRACKET\nCOMPOSICIÓN DE FUNCIONES\nEn Racket es posible anidar funciones, es decir, tener una función en la cual se tenga el llamado a otra función u otras funciones. Esto se hace con el propósito de unir funciones para lograr un solo objetivo.",
                "3": "\t\t\tC\nCOMPOSICIÓN DE FUNCIONES\nEn C existen llamados a funciones dentro de otras, esto se llama composición o anidación de funciones. Cada función retorna un valor que es usado en la función donde se realiza el llamado, esto para lograr un objetivo específico."
            },
            "3" : 
            {
                "1": "En este ejemplo se usa:\n\tComposición de Funciones\n\nDe Racket a C\n------------------\n(define d 0)(define m 0)(define a 0)\n\t\t\tVs.\nint d,m,a;\n------------------\n(cond \n\t((= mes 1)\n\t\t\tVs.\nswitch(mes){\n\tcase 1: \n------------------",
                "2": "\t\t\tRACKET\nCOMPOSICIÓN DE FUNCIONES\nEn Racket es posible anidar funciones, es decir, tener una función en la cual se tenga el llamado a otra función u otras funciones. Esto se hace con el propósito de unir funciones para lograr un solo objetivo.",
                "3": "\t\t\tC\nCOMPOSICIÓN DE FUNCIONES\nEn C existen llamados a funciones dentro de otras, esto se llama composición o anidación de funciones. Cada función retorna un valor que es usado en la función donde se realiza el llamado, esto para lograr un objetivo específico."
            },
            "4" : 
            {
                "1": "En este ejemplo se usa:\n\tComposición de Funciones\n\nDe Racket a C\n------------------\n(define (cantidad precio cantidad desc)\n\t(define valor 0)\n\t(set! valor (* precio cantidad))\n\t(descuento valor desc)\n)\n\t\t\tVs.\nfloat cantidad(float precio, float \ncantidad,\nfloat desc){\n\tfloat valor=0;\n\tvalor=precio*cantidad;\n\treturn descuento(valor, desc);\n}\n------------------",
                "2": "\t\t\tRACKET\nCOMPOSICIÓN DE FUNCIONES\nEn Racket es posible anidar funciones, es decir, tener una función en la cual se tenga el llamado a otra función u otras funciones. Esto se hace con el propósito de unir funciones para lograr un solo objetivo.",
                "3": "\t\t\tC\nCOMPOSICIÓN DE FUNCIONES\nEn C existen llamados a funciones dentro de otras, esto se llama composición o anidación de funciones. Cada función retorna un valor que es usado en la función donde se realiza el llamado, esto para lograr un objetivo específico."
            },
            "5" : 
            {
                "1": "En este ejemplo se usa:\n\tComposición de Funciones\n\nDe Racket a C\n------------------\n(define (maximo_comun_divisor a b)\n\t(define temporal 0)\n\t(while (not (= b 0))\n\t\t(set! temporal b)\n\t\t(set! b (remainder a b)\n\t\t(set! a temporal)\n\t)\n\ta\n)\n\t\t\tVs.\nint maximo_comun_divisor(int a, int b){\n\tint temporal;\n\twhile (b != 0) {\n\t\ttemporal = b;\n\t\tb = a % b;\n\t\ta = temporal;\n\t}\n\treturn a;\n}\n------------------",
                "2": "\t\t\tRACKET\nCOMPOSICIÓN DE FUNCIONES\nEn Racket es posible anidar funciones, es decir, tener una función en la cual se tenga el llamado a otra función u otras funciones. Esto se hace con el propósito de unir funciones para lograr un solo objetivo.",
                "3": "\t\t\tC\nCOMPOSICIÓN DE FUNCIONES\nEn C existen llamados a funciones dentro de otras, esto se llama composición o anidación de funciones. Cada función retorna un valor que es usado en la función donde se realiza el llamado, esto para lograr un objetivo específico."
            },
            "6" : 
            {
                "1": "En este ejemplo se usa:\n\tComposición de Funciones\n\nDe Racket a C\n------------------\n(define (multi a b)\n\t(if(or (= a 0) (= b 0))\n\t\t0\n\t\t(+ a (multi a (- b 1)))\n\t)\n)\n\t\t\tVs.\nfloat multi(float a, float b){\n\tif(a==0 || b==0)\n\t\treturn 0;\n\telse{\n\t\treturn a+multi(a,b-1);\n\t}\n}\n------------------",
                "2": "\t\t\tRACKET\nCOMPOSICIÓN DE FUNCIONES\nEn Racket es posible anidar funciones, es decir, tener una función en la cual se tenga el llamado a otra función u otras funciones. Esto se hace con el propósito de unir funciones para lograr un solo objetivo.",
                "3": "\t\t\tC\nCOMPOSICIÓN DE FUNCIONES\nEn C existen llamados a funciones dentro de otras, esto se llama composición o anidación de funciones. Cada función retorna un valor que es usado en la función donde se realiza el llamado, esto para lograr un objetivo específico."
            }
        },

        "procedimientos":
        {
            "1" : 
            {
                "1": "En este ejemplo se usa:\n\tProcedimientos\n\nDe Racket a C\n------------------\n(define numero 0)\n\t\t\tVs.\nint numero;\n------------------\n(set! numero (read))\n\t\t\tVs.\nscanf(\"%d\", &numero);\n------------------\n(analisis numero)\n\t\t\tVs.\nanalisis(numero);\n------------------",
                "2": "\t\t\tRACKET\nPROCEDIMIENTOS\nLos procedimientos en Racket son definiciones de funciones que cumplen con ciertas instrucciones las cuales no indican un retorno. Se usan normalmente para procesos de ordenamiento, mensajes en pantalla, etc.",
                "3": "\t\t\tC\nPROCEDIMIENTOS\nEn C los procedimientos se definen como cualquier otra función, la característica especial sobre dichas funciones es que no retornan nada, es decir, retorno vacio (void)."
            },
            "2" : 
            {
                "1": "En este ejemplo se usa:\n\tProcedimientos\n\nDe Racket a C\n------------------\n(do ((i 1 (+ i 1))) ((and (> ms 0)(< ms 13)))\n)\n\t\t\tVs.\ndo{\n}while(mes>0 && mes<=12);\n------------------\n(cond\n\t((= mes 1)\n\t\t\tVs.\nswitch(mes){\n\tcase 1:\n------------------",
                "2": "\t\t\tRACKET\nPROCEDIMIENTOS\nLos procedimientos en Racket son definiciones de funciones que cumplen con ciertas instrucciones las cuales no indican un retorno. Se usan normalmente para procesos de ordenamiento, mensajes en pantalla, etc.",
                "3": "\t\t\tC\nPROCEDIMIENTOS\nEn C los procedimientos se definen como cualquier otra función, la característica especial sobre dichas funciones es que no retornan nada, es decir, retorno vacio (void)."
            },
            "3" : 
            {
                "1": "En este ejemplo se usa:\n\tProcedimientos\n\nDe Racket a C\n------------------\n(define (cuadrado c lado)\n)\n\t\t\tVs.\nvoid cuadrado(char c, int lado){\n}\n------------------\n(set! lado (read))\n\t\t\tVs.\nscanf(\"%d\", &lado);\n------------------\n(cuadrado c lado)\n\t\t\tVs.\ncuadrado(c, lado);\n------------------",
                "2": "\t\t\tRACKET\nPROCEDIMIENTOS\nLos procedimientos en Racket son definiciones de funciones que cumplen con ciertas instrucciones las cuales no indican un retorno. Se usan normalmente para procesos de ordenamiento, mensajes en pantalla, etc.",
                "3": "\t\t\tC\nPROCEDIMIENTOS\nEn C los procedimientos se definen como cualquier otra función, la característica especial sobre dichas funciones es que no retornan nada, es decir, retorno vacio (void)."
            },
            "4" : 
            {
                "1": "En este ejemplo se usa:\n\tProcedimientos\n\nDe Racket a C\n------------------\n(if (and (= dia 31)  (= mes 12))\n\t\t\tVs.\nif(dia==31 && mes==12){\n------------------\n(set! d (read))\n\t\t\tVs.\nscanf(\"%d\", &d);\n------------------\n(fecha_siguiente d m a)\n\t\t\tVs.\nfecha_siguiente(d,m,a);\n------------------",
                "2": "\t\t\tRACKET\nPROCEDIMIENTOS\nLos procedimientos en Racket son definiciones de funciones que cumplen con ciertas instrucciones las cuales no indican un retorno. Se usan normalmente para procesos de ordenamiento, mensajes en pantalla, etc.",
                "3": "\t\t\tC\nPROCEDIMIENTOS\nEn C los procedimientos se definen como cualquier otra función, la característica especial sobre dichas funciones es que no retornan nada, es decir, retorno vacio (void)."
            },
            "5" : 
            {
                "1": "En este ejemplo se usa:\n\tProcedimientos\n\nDe Racket a C\n------------------\n(define (imprimir_vector vec tam)\n\t(printf \"\\n***EL VECTOR ES: ***\\n\")\n\t(for ([i (in-range 0 tam 1)])\n\t\t(printf \"~a \" (vector-ref vect i))\n\t)\n)\n\t\t\tVs.\nvoid imprimir_vector(int vector[], int\ntamano){\n\tprintf(\"\\n***EL VECTOR ES: ***\\n\");\n\tfor(int i=0; i<tamano; i++){\n\t\tprintf(\"%d \", vector[i]);\n\t}\n}\n------------------",
                "2": "\t\t\tRACKET\nPROCEDIMIENTOS\nLos procedimientos en Racket son definiciones de funciones que cumplen con ciertas instrucciones las cuales no indican un retorno. Se usan normalmente para procesos de ordenamiento, mensajes en pantalla, etc.",
                "3": "\t\t\tC\nPROCEDIMIENTOS\nEn C los procedimientos se definen como cualquier otra función, la característica especial sobre dichas funciones es que no retornan nada, es decir, retorno vacio (void)."
            },
            "6" : 
            {
                "1": "En este ejemplo se usa:\n\tProcedimientos\n\nDe Racket a C\n------------------\n(define (main)\n\t(define tam 0)\n\t(printf\n\t\"Ingrese un tamano para el vector: \")\n\t(set! tam (read))\n\t(define vect (make-vector tam 0))\n\t(llenar_vector vect tam)\n)\n\t\t\tVs.\nint main(){\n\tint tamano;\n\tprintf(\n\t\"Ingrese un tamano para el vector: \");\n\tscanf(\"%d\", &tamano);\n\tint vector[tamano];\n\tllenar_vector(vector, tamano);\n}\n------------------",
                "2": "\t\t\tRACKET\nPROCEDIMIENTOS\nLos procedimientos en Racket son definiciones de funciones que cumplen con ciertas instrucciones las cuales no indican un retorno. Se usan normalmente para procesos de ordenamiento, mensajes en pantalla, etc.",
                "3": "\t\t\tC\nPROCEDIMIENTOS\nEn C los procedimientos se definen como cualquier otra función, la característica especial sobre dichas funciones es que no retornan nada, es decir, retorno vacio (void)."
            }
        }
    }
]